# 1. TCP和UDP的区别
> 首先 TCP 和 UDP 都是传输层协议
- 连接方面
  - TCP 是面向连接的
  - UDP 是无法连接的，即发送数据之前不需要建立连接
- 安全方面
  - TCP 提供可靠的服务，提供 TCP 连接传送的数据，无差别，不丢失，不重复，且按序列到达
  - UDP 尽最大努力交付，既不保证可靠交付
- 传输效率
  - TCP 是面向字节流的，所以 TCP 的传输效率相对较低
  - UDP 是面向数据报的，所以 UDP 传输效率较高，适用于高速传输和实时性有较高性的通信和广播通信
- 连接对象的区别
  - TCP 连接只能是点到点，一对一的
  - UDP 支持一对一，一对多，多对一的交互通信    


# 2. TCP三次握手
三次握手的意义在于确定双方都能够完成读写操作
作用：三次握手的目的是为确认客户端和服务端都具有 `接收` 和 `发送` 的能力
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA3MjA1NzA5MzY3?x-oss-process=image/format,png">

## 握手过程

> 最开始客户端和服务端都处于`CLOSED`状态，
- 第一次握手
  - 主要传递传递两个信息，一个是请求连接（SYN=1），二是发出一个序列号(seq=n)。
  - 这个时候客户端的状态 `SYN-SENT` 状态
  - 第一次握手让服务端知道客户端可以发送信息
- 第二次握手
  - 这次回复三个信息，一是同意建立连接（SYN=1），二是确认收到刚才的信息（ask=刚才的seq+1），三是发出自己的序列号（seq=x）。
  - 这个时候服务端的状态是`SEND-RCVD`
  - 第二次握手让客户端知道服务端既能收到也能发出
- 第三次握手
  - 这次回复三个信息，一是表示现在开始发送（SYN=0），二是成功收到了刚才的信息（ask=刚才的seq+1）,三是发出自己的序列号（最开始发出序列号+1）。
  - 这个时候客户端状态变成了`ESTABLISHED`，服务端的状态变成了`ESTABLISHED`
  - 第三次握手让服务端知道了客户端既能收到也能发出

## 2-1. 为什么TCP握手不是两次和四次呢？
- 两次无法确认客户端的接收能力。
- 四次也可以，但是三次就能解决问题了，再多用处不大。


## 2-2. 三次握手中可以携带数据吗？
第三次握手的时候可以携带，前两次不能携带数据。

如果前两次都能携带数据的话，一旦有人想攻击服务器，那么它只需要在第一次握手中的报文中放大量数据，那么服务器势必会消耗更多的 `时间` 和 `内存空间` 去处理这些数据，增大服务器被攻击的风险。

第三次握手的时候，客户端已经处于 `ESTABLISHED` 状态，并且确认服务器具有`接收`和`发送`的能力，这个时候相对安全些，可以携带数据。


## 2-3. 如果客户端和服务端在三次握手的时候同时发送 `SYN` 报文的时候，状态会是怎么样的
> 状态变迁
- 在发送方给接受方发 `SYN报文` 的同时，接收方也给发送方发 `SYN报文`
- 发送完 `SYN`，两者的状态为 `SYN-SENT`
- 在各自接受对方的 `SYN`后，两者的状态都变为 `SYN-RCVD`
- 接着会回复对应的 `ACK+SYN`，这个报文在对方接受之后，两者状态一起变成 `ESTABLISHED`


## 2-4. 如果已经建立连接，但是客户端突然出现故障了怎么办？
TCP 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 个小时，若两个小时还没收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

# 3. 四次挥手流程
**四次挥手核心就在于四个时间节点，分别是 `发完了`，`知道发完了`,`收完了`,`知道收完了`**

## 四次挥手
- 第一次挥手，A 告诉 B 数据发送完了。
  - 这个时候相当于 A 向 B 传输数据，数据传递完了，但是数据传递完了之后，不能直接断开，因为 B 并不知道数据传递完了。
- 第二次挥手，B 知道 A 发完了。
  - 因为 B 还没接受完数据，所以虽然知道 A 把数据传完了，所以只能先回复 A 知道你传完了。
- 第三次挥手，B 直接告诉 A 接收完了
  - 这时，虽然 A 已经发送完了数据，但是还不确定 B 接受完数据，所以 A 还要等着，因为一旦 B 没有接受成功，A 还要继续发送。所以 A 要等着 B 反馈接受完了，才能真正断开连接。所以当 B 接受完数据的时候，B 要告诉 A 接收完了。
- 第四次挥手，A 知道 B 接受完了
  - 这时 A 知道 B 接收完数据了，就可以放心的断开连接了。

## 3-1. 为什么握手只需要三次，而挥手却需要四次
就是因为当 A 告诉 B 发送完了的时候，B 还有可能没接收完信息，所以只能先回复一部分，告诉 A 已经接受完了的信息了。当消息完全接受完毕之后，才会告诉 A 已经接受完了。

# 4. HTTP 各版本特性及区别？
**HTTP 是基于 TCP/IP 协议的一个应用层协议，是现代互联网的一个基础协议。规定了客户端和服务端之间的通信格式以及所占的服务端口80（HTTPS是443）**

## HTTP 0.9
- **只支持 `GET` 请求方式：**由于不支持其它请求方式，因此客户端是没办法向服务端传输太多的信息
- **没有请求头的概念：**所以不能在请求中指定版本号，服务端也只具有返回HTML字符串的能力
- **服务端响之后，立即关闭TCP连接**

## HTTP1.0
**这个版本主要对请求和响应的元信息进行了拓展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容**

- **请求方式新增了`POST`丶`DELETE`丶`PUT`丶`HEADER`等方式**
- **增添了请求头和响应头的概念，在通信中指定了HTTP协议版本号，以及其它的一些元信息**
- **扩充了传输内容格式，图片，音视频资源丶二进制等都可以进行传输**

**特性：**

- 无状态：服务器不跟踪不记录请求过的状态
- 无连接：浏览器每次请求都需要建立tcp连接

**无状态:对于无状态的特性可以借助 cookie/session 机制来做身份认证和状态记录。**

**无连接的性能缺陷有两种：**

- **无法复用连接：**每次发送请求，都需要进行进行 TCP 连接（即三次握手四次挥手），使得网络的利用率非常低
- **队头阻塞：**HTTP1.0 规定在前一个请求到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的


## HTTP1.1
**在 1.0 发布后的半年就推出了，完善了 1.0 版本。目前也还有好多的互联网项目基于 HTTP1.1 向外提供服务**

**特性：**

- **长连接：**新增 Connection 字段，可以设置 keep-alive 值保持不断开。HTTP 1.1默认
- **管道化：**基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回
- **缓存处理：**新增字段 cache-control，当浏览器请求资源时，先看是否有缓存的资源，如果有直接取，不会再发请求，如果没有缓存则发送请求。通过设置cache-control 来控制缓存。
- **断点续传：**在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率。


**非管道化请求响应：**
```js
请求1 > 响应1 ---> 请求2 > 响应2 --> 请求3 > 响应3
```
**管道化的请求响应：**

```js
请求1 --> 请求2 --> 请求3 > 响应1 --> 响应2 --> 响应3
```
即使服务器先准备响应2，也是按照请求顺序先返回响应1

**虽然管道化，可以因此发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题**


## HTTP2
**特性：**

- **二进制分帧：** HTTP1.x 的解析是基于文本，HTTP2 之后将所有的传输的信息分割成更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率
- **多路复用：** 在共享 TCP 链接的基础上同时发送请求和响应，基于二进制分帧，再同一域名下所有访问都是从同一个 TCP 连接中走，HTTP 消息被分解为独立的帧，乱序发送，服务端根据标识符和首部信息重新组装起来。
- **头部压缩：** 由于 HTTP 是无状态的，每个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢累积上去。所以 HTTP2 就可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源
- **服务器推送：** 服务器可以额外的向客户端推送资源，而无需客户端明确的请求

<img src="https://segmentfault.com/img/bVvvaN">

**HTTP2的缺点**

- TCP 以及 TCP+TLS 建立连接的延时，HTTP2 使用 TCP 协议来传输的，而如果使用 HTTPS，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，在传输数据之前，导致我们需要花掉 3-4 个RTT
- TCP 的队头阻塞并没有彻底解决。在 HTTP2 中，多个请求是跑在一个 TCP 管道中的。当 HTTP2 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该TCP连接中的所有请求。

**HTTP与HTTPS的区别**
　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全

## SPDY协议 SPeedy
2012 年 Google 如一声惊雷的提出了 SPDY 的方案，大家才开始从正面看待和解决老版本 HTTP 协议本身的问题，SPDY 可以是综合了 HTTPS 和 HTTP 两者于一体的传输协议，主要解决：

- **减低延迟：**针对 HTTP 高延迟的问题，SPDY 优雅的采取了多路复用。多路复用通过多个请求 stream 共享一个 TCP 连接的方式，解决了 HOL blocking 的问题，降低了延迟同时提高宽带的利用率。

- **请求优先级：**多路复用带来的一个新的问题是，在连接共享的基础之上可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先级，这样重要的的请求都会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件被加载，这样可以保证用户能第一时间看到网页内容。

- **header压缩：**前面提到的 HTTP1.x 的 header 很多时候都是重复多余的，选择合适的压缩算法都可以减少包的大小和数量。

- **基于 HTTPS 的加密协议传输：**这大大提高传输数据的可靠性

- **服务端推送：**采用了 SPDY 的网页，例如我的网页有一个 style.css 的请求，在客户端收到 style.css 数据的同时，服务端会将 style.js 的文件推送给客户端，当客户端再次尝试霍获取 style.js 时就可以直接从缓存中获取到，不用再发请求了

**SPDY 位于 HTTP 之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议（将HTTP1.x的内容封装成一种新的frame格式，同时可以使用已有的SSL功能）**

## SPDY 和 HTTPP2 的区别

- **头部压缩算法：**SPDY，通用的deflate算法；HTTP2，专门为压缩头部设计的HPACK算法
- **SPDY 必须在 TSL 上运行，HTTP2 可在 TCP 上直接使，因为增加了 HTTP1.1 的 Upgrade 机制更加完善的协议商讨和确认流程**
- **更加完善的 Server Push（服务端推送）流程**    
- **增加控制帧的种类，并对帧的格式考虑得更细致**

## **HTTP3**

Google 在推 SPDY 的时候就已经意识到了这些问题，于是就另起炉灶搞了基于 UDP 协议的"QUIC"协议，让 HTTP 跑在 QUIC 上而不是 TCP 上。主要特性是：

- **实现了类似 TCP 的流量控制丶传输可靠性的功能：**虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础上增加了一层来保证数据可靠性传输。它提供了数据包重传丶拥塞控制以及其它一些TCP中存在的特性。
- **实现了快速握手功能：**由于 QUIC 是基于 UDP 的，所以 UDP 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 OUIC 可以用最快的速度来发送和接受数据
- **集成了 TSL 加密功能：**目前 QUIC 使用的是 TSL1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数
- **多路复用，彻底解决了 TCP 中队头阻塞的问题**  

## HTTPS 加密原理？

传统的 HTTP 协议基于 TCP/IP 协议来传递数据，客户端通过三次握手与服务端建立连接。HTTPS 在传输数据之前需要客户端与服务端进行一次握手，在握手的过程中确认双方加密传输数据的密码信息。TLS/SSL 使用非对称加密丶对称加密以及 HASH 算法。

**握手过程简单描述如下：**

- 浏览器向服务器发送自己所支持的加密规则
- 服务器从中选取一组加密算法与 HASH 算法，将自己的身份信息以证书（CA）的形式返回给浏览器。证书里面包含网站地址丶加密公钥S_PuKey以及证书的颁发机构等信息。
- 客户端确认其颁发的证书的有效性，如果证书有效浏览器会生成一串随机数的密码C_Key，并用证书提供的公钥S_PuKey加密。然后客户端使用约定好的HASH计算握手信息，并使用生成的随机数C_Key对消息进行加密，最后将之前生成的所有信息发送给浏览器。

### 为什么需要加密？

因为 HTTP 的内容是明文传输的，明文传输是经过中间代理服务器丶路由器丶WiFi热点丶通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露。劫持者还可以篡改传输的信息且不被双方觉察，这就是中间人攻击。所以我们才需要对信息进行加密。最容易理解的就是对称加密。

### 什么是对称加密？

简单说就是有一个密钥，它可以加密一段信息，也可以对加密后的信息进行解密，和我们日常生活中的钥匙作用差不多。

<img src="https://pic1.zhimg.com/80/v2-1252526c263ee50c47b7b49bd1c2ef44_720w.jpg">

### 用对称加密可行吗？

如果通信双方都各持有同一个密钥，且没有别人知道，这两方的通信当然是可以被保证的（除非密钥被破解）。

然而最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。如果由服务器生成一个密钥并传输给浏览器，那么在这个传输过程中密钥被别人劫持到手了怎么办？之后他就能用密钥解开双方传输的任何内容了，所以这样做当然不行。

换种思路？试想下，如果浏览器内部就预存了网站 A 的密钥，且可以确保了浏览器和网站 A，不会由任何人知道密钥，那理论上用对称加密是可以的，这样浏览器只要预存好世界上所有 HTTPS 网站的密钥就行了？只要做显然是不显示。

怎么办？所有我们就需要非对称加密。

### 什么是非对称加密？

简单来说有两把密钥，通常一把叫公钥丶一把叫私钥，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥才能解开。

<img src="https://pic1.zhimg.com/80/v2-1589bbfab027eb9f52da03c02a837fd4_720w.jpg">

### 用非对称加密可行吗？

鉴于非对称加密的机制，我们可能会有这种思路：服务器先把公钥以明文方式传输给浏览器，之后浏览器向服务器传数据前都先使用这个公钥加密好再传，这条数据的安全似乎可以保障了！因为只有服务器有相应的私钥解开公钥加密的数据。

然而反过来由服务器到浏览器的这条路怎么保障安全？如果服务器用它的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，若这个公钥被中间人劫持到了，那他也能用该公钥解密服务器传来的信息了。所以目前似乎只能保证由浏览器向服务器传输数据的安全性（其实仍有漏洞丶下文会说），那利用这点您能想到什么解决方案吗？

### 改良的非对称加密方案，似乎可以？

我们已经理解通过一组公钥私钥，可以保证单个方向传输的安全性，那用两组公钥私钥，是否就能保证双向传输都安全了？

- 某网站服务器拥有一组公钥A与对应的私钥A’；浏览器拥有公钥B与对应的私钥B‘
- 浏览器把公钥B明文传输给服务器
- 服务器把公钥A明文给传输浏览器
- 之后浏览器向服务器传输的内容都用公钥A加密；服务器收到后用私钥A'解密。由于只有服务器拥有私钥A‘，所以能保证这条数据的安全
- 同理，服务器向浏览器传输的内容都用公钥B加密，浏览器收到后用私钥B'解密。同上也可以保证这条数据的安全

的确可以！抛开这里仍有的漏洞不谈。HTTPS的加密却没使用这种方案，为什么？
很重要的原因是非对称加密算法非常耗时，而对称加密快很多。那我们能不能运用非对称加密的特性解决前面提到的对称加密的漏洞？

### 非对称加密+对称加密？

既然非对称加密耗时，那非对称加密+对称加密结合可以吗？而且得尽量减少非对称加密的次数。

当然是可以的，且非对称加密丶解密各需用一次即可。

请看一下这个过程：

- 某网站拥有用于非对称加密的公钥 A丶私钥 A'
- 浏览器向网站服务器请求，服务器把公钥明文给传输浏览器
- 浏览器随机生成一个用于对称加密的秘钥 X，用公钥 A 加密传输给服务器。
- 浏览器拿到后用公钥 A'，解密得到秘钥 X
- 这样双方就都拥有秘钥 X 了，且别人无法知道它。之后双方所有数据都通过秘钥 X 加密解密即可。

完美！HTTPS 基本就是采用了这种方案。完美？还是有漏洞的。

#### 中间人攻击

<img src="https://pic2.zhimg.com/80/v2-daeb6b8b0ac5411d51d60bd08b551789_720w.jpg">



如果在数据传输过程，中间人劫持到了数据，此时他的确无法得到浏览器生成的密钥 X，这个密钥本身被公钥 A 加密了，只有服务器才有 A'，解开它，然而中间人却完全不需要拿到私钥 A'，就能干坏事了。请看：

- 某网站有用于对称加密的公钥A丶私钥A'
- 浏览器向网站服务器请求，服务器把公钥 A明文传输给浏览器
- 中间人劫持到公钥 A，保存下来，把数据包中的明文传输 A 替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）
- 浏览器生成一个用于对称加密的密钥 X，用公钥 B（浏览器无法得知公钥被替换了）加密后传给服务器。
- 中间人劫持后用私钥 B' 解密得到密钥 X，再用公钥 A 加密后传给服务器
- 服务器拿到后私钥 A'，解密得到密钥 X

这样在双方都不会发现异常的情况下，中间人通过一套“礼貌换太子”的操作，掉包了服务器传来的公钥，进而得到了密钥X。根本原因是浏览器无法确认收到的公钥是不是网站自己的，因为公钥本身是明文传输的，难道还得对公钥的传输进行加密？这似乎变成鸡生蛋丶蛋生鸡的问题了。解法是什么？

### 如何证明浏览器收到的公钥一定是该网站的公钥？

其实所有的证明的源头都是一条或多条不证自明的“公理”（可以回想到数学上公理），有它推导出一切。比如现实生活中，若想证明某身份证号一定是小明的，可以看他身份证，而身份证是由政府作证的，这里的“公理”就是”政府机构可信“，这也是社会正常运行的前提。

那能不能类似地有个机构充当互联网世界的“公理”呢？让它作为一切证明的源头，给网站颁发一个身份证。

它就是 CA机构，它是如今互联网世界正常运作的前提，而CA 机构颁发的“身份证“就是数字证书。

<img src="https://pic2.zhimg.com/80/v2-1123c51b7d4a0db707100971b91728a9_720w.jpg">

网站在使用 HTTPS 前，需要向 CA机构 申领一份数字证书，数字证书里包含证书持有者信息丶公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证明“该公钥对应该网站”，而这里又有显而易见的问题，“证书本身的传输过程中，如何防止被篡改’？即如何证明本身的真实性？身份证运用了一些防伪技术，那数字证书如何防伪呢？解决这个问题我们就接近胜利了！

### 如何放防止数字证书被篡改？

#### 数字签名

这部分内容建议看下图并结合后面的文字理解，图中左侧是数字签名的制作过程，右侧是验证过程：

<img src="https://pic2.zhimg.com/v2-7c78935389af46e197e96d9cd91c06dd_r.jpg">



**数字签名的制作过程：**

- CA 机构拥有非对称加密的私钥和公钥
- CA 机构对证书明文数据 T 进行 hash
- 对 hash 后的值用私钥加密，得到数字签名 S

明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。

那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改丶掉包）

**浏览器验证过程：**

- 拿到证书，得到明文 T，签名S
- 用 CA 机构的公钥对 S 解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到 S'
- 用证书里指明的 hash 算法对明文 T 进行 hash 得到 T'
- 显然通过以上步骤，T' 应当等于 S‘，除非明文或签名被篡改。所以此时比较 S' 是否等于 T'，等于则表明证书可信。

为何这样可以保证证书可信呢？我们来仔细想一下。

### 中间人有可能篡改该证书吗？

假设中间人篡改了证书的原文，由于他没有 CA 机构的私钥，所以无法得知此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后地值不一致，则说明书已被篡改，证书不可行，从而终止向服务器传输信息，防止信息泄露给中间人。

既然不可能篡改，那整个证书被掉包呢？

### 中间人有可能把证书掉包吗？

假设有另一个网站 B 也拿到了 CA 机构认证地证书，它想劫持网站A的信息。于是它成为中间人拦截到了 A 传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误的拿到 B 的证书里的公钥了，这的确会导致上文”中间人攻击”那里提到的漏洞？

其实这并不会发生，因为证书里包含了网站A 的信息，包括域名，浏览器把证书里的域名与自己请求的域名对比一下就知道有没有被掉包了。

### 为什么制作数字签名时需要 hash 一次？
  - hash 后得到的是固定长度的信息（比如 md5 算法 hash 后得到固定的 128 位的值），这样加解密就快很多。

我初识 HTTPS 的时候就有整个疑问，因为似乎哪里的 hash 有点多余吗，把 hash 过程去掉也能保证证书没有被篡改。

最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而 hash 后得到的是固定长度的信息（比如 md5 算法 hash 后得到固定的 128 位的值），这样加解密就快很多。

当然也有安全上的原因。

### 怎么证明 CA 机构的公钥是可信的？

你们可能会发现上文说到 CA 机构的公钥，我几乎一笔带过，“浏览器保有它的公钥”，这是个什么保有法？怎么证明这个公钥是否可信？

让我们回想一下数字证书到底是干啥的？没错，为了证明某公钥是可信的，即“该公钥是否对应该网站”，那 CA 机构的公钥是否可以用数字证书来证明？没错，操作系统丶浏览器本身会预装一些它们信任的根证书，如果其中会有 CA 机构的根证书，这样就可以拿到它对应的可信公钥了。

实际上证书之间的认证也可以不止一层，可以 A 信任 B，B 信任 C，以此类推，我们把它叫做 信任链 或 数字证书链。也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。

另外，不知你们是否遇到网站访问不了丶提示需要安装证书的情况？这里安装的就是根证书。说明浏览器不认给这个网站颁发证书的机构，那么你就得手动下载该机构得根证书（风险自己承担XD）。安装后，你有了它得公钥，就可以用它验证服务器发来得证书是否可信了。

<img src="https://pic2.zhimg.com/80/v2-04cd27f3f46388df2d8d70375c4ecac5_720w.jpg">

### 每次进行 HTTPS 请求时都必须在 SSL/TLS 层进行握手传输密钥吗？

这也是我们当时的困惑之一，显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？

服务器会为每个浏览器（或客户端软件）维护一个session ID，在 TLS 握手阶段传给浏览器，浏览器会生成密钥传给服务器后，服务器会把该密钥存到对应的 session ID 下，之后浏览器每次请求都会携带 session ID，服务器会根据 session ID 找到相应的密钥进行加密解密操作，这样就不必要每次重新制作丶传输密钥了！

总结

可以看下这张图，梳理下整个流程（SSL丶TSL握手有一些区别，不同版本间也有区别，不过大致过程就是这样）：

<img src="https://pic2.zhimg.com/80/v2-a0d10af45e785fe8d3f5cd12f8c309f5_720w.jpg">

## HTTPS原理解析过程：

<img src="https://segmentfault.com/img/bVbClUl">

- 客户端请求 HTTPS 网址，然后连接到 server 的 443 端口(HTTPS 默认端口，类似于 HTTP 的 80 端口）

- 采用 HTTPS 协议的服务器必须有一套数字 CA（Certication Authority)证书，证书是需要申请的，并由专门的数字证书认证机构（CA）通过非常严格的审核之后颁发的电子证书（当然了是要钱的，安全级别越高价格越贵）。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。

- 服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其它信息，比如证书颁发机构信息，公司信息和证书有效期等。Chrome 浏览器点击地址栏的锁标志再点击证书就可以看到证书详情信息。

  <img src="https://segmentfault.com/img/bVbClUt">

- 客户端解析证书并对其进行验证。如果证书不是可信机构颁发，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。就像下面这样：

  <img src="https://segmentfault.com/img/bVbClUs">

  如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥 A 将其加密。

- 客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥
- 服务器在收到随机码 KEY 之后会再使用私钥 B 将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄漏问题，接下来就可以用对称加密愉快地进行通信了。
- 服务器使用密钥（随机码 KEY）对数据进行对称加密并发给客户端，客户端使用相同地密钥（随机码 KEY）解密数据。
- 双方使用对称加密愉快地传输所有数据



## HTTPS 和HTTP 的区别？

HTTP 协议传输的数据都是未加密的，也就是明文，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私信息能加密传输，于是网景公司设计了SSL（Secure Sockets Layer ）协议用于对HTTP协议传输的数据进行加密，从而诞生了 HTTPS。

简单来说，HTTPS协议是由 SSL+HTTP 协议构建的可进行加密传输丶身份认证的网络协议，要比HTTP协议安全

**HTTPS和HTTP的区别主要如下：**

- HTTPS 协议需要到 CA申请证书，一般免费证书较少，因而需要一定费用
- HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议
- HTTP 和HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443
- HTTP 的连接方式很简单，是无状态的；HTTPS 协议是由 SSL 和 HTTP 协议构建的可进行加密传输丶身份认证的网络协议，比HTTP协议安全
- HTTP 页面响应速度比 HTTPS 快，由于加了一层安全层，建立连接地过程更复杂，也要交换更多地数据，难免影响速度。
- 由于 HTTPS 是构建在 SSL/TLS 之上的 HTTP 协议，所以要比 HTTP 更耗费服务器资源

**HTTPS 的缺点：**

- 在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。
- HTTPS 的安全是由范围的，在黑客攻击丶服务器劫持等情况下几乎起不到作用
- 在现有的证书机制下，中间人攻击依然有可能发生
- HTTPS 需要更多的服务器资源，也会导致成本的升高

# 4.HTTPS 建立连接的详细过程

**1. 客户端发起HTTPS连接**
**2. 服务端发送证书**
**3. 客户端验证服务端发来的证书**
**4. 服务端接受随机数加密的信息，验证并解密得到随机数，验证握手信息是否被篡改**
**5. 客户端验证服务端发送回来的握手信息，完成握手**


HTTPS 是在 HTTP 的基础上和SSL/TLS证书结合起来的一种协议，保证传输过程中的安全性，减少了被恶意劫持的可能，很好的解决了HTTP的三个缺点（被监听丶被篡改丶被伪装）

## **1. 客户端发起HTTPS连接**

当用户在浏览器地址敲击`baidu.com`，浏览器回去DNS服务器获取URL对应的IP地址，然后客户端连接服务端的443端口，将此请求发送给服务端，此时客户端同时将自己的支持的加密算法带给服务端。

## **2. 服务端发送证书**

非对称加密：私钥加密的密文只有公钥才能解开，公钥加密的密文只有私钥才能解开。

服务端收到这套加密算法的时候，和自己支持的加密算法进行对比（也就是和自己的私钥进行对比），如果不符合就断开连接；如果符合，服务端就将CA证书发送给客户端，此证书包括了数字证书包含的内容：1. 证书颁发机构 2. 使用机构 3. 公钥 4. 有效期 5. 签名算法 6. 签名Has算法 7. 指纹算法 8. 指纹

这里服务端发送的东西是用私钥进行加密的，公钥都能解开，并不能保证发送的数据包不被别人看到，所以后面的过程会和客户端选择一个对称加密来对传输的数据进行加密。

## **3. 客户端验证服务端发来的证书**

1. 验证证书

客户端验证收到的证书，包括发布机构是否合法丶过期， 证书中包含的网址是否与当前访问的网址一致等等。

2. 生成随机数（此随机数就是后面用的对称加密的私钥）

客户端验证证书无误后（或者接受了不信任的证书），会生成一个随机数，用服务端发过来的公钥进行加密。如此一来，此随机数只有服务端的私钥能解开了。

3. 生成握手信息

用证书中签名hash算法取握手信息的hash值，然后用生成的随机数对【握手信息和握手信息的hash】进行加密。然后用公钥将随机数进行加密后，一起发送给服务端。其中计算握手信息的hash值，目的是为了保证传回到服务端的握手信息没有被篡改。

## **4. 服务端接受随机数加密的信息，验证并解密得到随机数，验证握手信息是否被篡改**

服务端收到客户端传回来的用随机数加密的信息后，先用私钥解密随机数，然后用解密得到的随机数解密握手信息，获取握手信息和握手的hash值，计算自己发送的握手信息的hash值，与客户端传回来的进行对比验证。

如果验证无误，同样使用随机数字符串加密握手信息和握手信息hash值发回给客户端。

## **5. 客户端验证服务端发送回来的握手信息，完成握手**

客户端收到服务端发送过来的握手信息后，用开始自己生成的随机数进行解密，验证被随机数加密的握手信息和握手信息hash值。

验证无误后，握手过程就完成了，从此服务端和客户端就开始用那串随机数进行对称加密通信

<img src="https://pic2.zhimg.com/80/v2-22c7091dfa8fb587d9f37d7c3edc387d_720w.jpg">


# 5. 输入url到页面呈现
## url包括
  host - 定义域主机（http 的默认主机是 www）
  domain - 定义因特网域名，比如 w3school.com.cn
  port - 定义主机上的端口号（http 的默认端口号是 80）
  path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。
  filename - 定义文档/资源的名称

## 域名解析
  - 浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。
  - 操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。
  - 路由缓存：路由器也有 DNS 缓存。
  - ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。
  - 根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）

## TCP三次握手
在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。

作用：三次握手的目的是为确认客户端和服务端都具有 `接收` 和 `发送` 的能力

- 客户端发送一个是请求连接（SYN=1），二是发出一个序列号(seq=n) 的数据包到服务器端口（第一次握手让服务端知道客户端可以发送信息）


- 服务器发回一个带 一是同意建立连接（SYN=1），二是确认收到刚才的信息（ask=刚才的seq+1），三是发出自己的序列号（seq=x）。（第二次握手让客户端知道服务端既能收到也能发出）


- 客户端再回传一个带 一是表示现在开始发送（SYN=0），二是成功收到了刚才的信息（ask=刚才的seq+1）,三是发出自己的序列号（第三次握手让服务端知道了客户端既能收到也能发出）

## 发送HTTp请求
TCP 三次握手结束后，开始发送 HTTP 请求报文。 请求报文由请求行（request line）、请求头（header）、请求体四个

## 服务器处理请求并返回 HTTP 报文

## 浏览器解析渲染页面
浏览器拿到响应文本 HTML 后，进行解析和渲染

### 1.根据 HTML 解析 DOM 树
根据 HTML 的内容，将标签按照结构解析成为 DOM 树，在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。

### 2.根据 CSS 解析生成 CSS 规则树
解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。
浏览器在 CSS 规则树生成之前不会进行渲染。

### 3.结合 DOM 树和 CSS 规则树，生成渲染树

### 4.根据渲染树计算每一个节点的信息（布局）
布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸
回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。

### 5.根据计算好的信息绘制页面
绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。
重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。
回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。

## 断开连接
当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手
- 客户端发起断开连接的请求，发送报文，Fin、Ack、Seq序列号，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)

- 服务端发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)

- 服务端发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)

- 客户端发起断开连接，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)

# 5. 从输入URL到页面展示到底发生了什么？

- 输入地址
- 浏览器查找域名的IP地址
- 浏览器向 web 服务器发送一个 HTTP 请求
- 服务器的永久重定向响应
- 服务器处理请求
- 服务器返回一个 HTTP 响应
- 浏览器显示 HTML
- 浏览器发送请求获取在 HTML 中的资源（如图片丶音频丶视频丶CSS丶JS等等）


## 1. 输入地址

当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能匹配可能得 URL 了，他会从历史记录丶书签等地方，找到已经输入的字符串可能对应的 URL ，然后给出智能提示，让你补全 URL 地址。

对于 Google 的 Chrome 浏览器，它甚至会直接从缓存中把网页展示出来，就是说你还没有按下 enter,页面就出来了。


## 2. 浏览器查找域名的 IP 地址
- 请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地的硬盘的 `hosts` 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 `host` 文件里面的 `IP` 地址。
- 如果在本地的 `hosts` 文件没有找到对应的 `IP` 地址，浏览器会发出一个 `DNS`  请求到 `本地DNS服务器`。`本地DNS服务器` 一般都是你的网络接入服务商提供，比如中国电信丶中国移动等
- 查询你输入的网址的 DNS 请求到达本地 DNS 服务器之后，本地 DNS 服务器会首先查询它的缓存记录，如果缓存记录中有此条记录，就可以直接返回结果，此过程是 `递归的方式` 进行查询。如果没有，本地 DNS 服务器还要向 `DNS根服务器` 进行查询。
- `DNS根服务器` 没有记录具体的域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器，你可以到 `域服务器` 上去继续查询，并给出域服务器的地址。这种过程是`迭代的过程`。
- 本地 DNS 服务器继续向域服务器发出请求，在这个例子中，请求的对象是`.com域服务器`。`.com域服务器`收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。
- 最后，本地 DNS 服务器向域名的解析器发出请求，这时就能收到一个域名和 IP 地址对应关系，本地  DNS 服务器不仅要把 IP 地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询，可以直接返回结果，加快网络访问。 

<img src="https://pic3.zhimg.com/80/v2-367da995706289a83af5c0372d55f43e_1440w.jpg">


## 3.浏览器向 web 服务器发送一个 HTTP 请求

拿到域名对应的 IP 地址之后，浏览器会以一个随机端口（1024<端口<65535）向服务器的Web程序（常用的有http丶nginx等）80 端口发起 TCP 的连接请求。这个连接请求到达服务端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的 TCP/IP 协议栈（用于识别该连接请求丶解封包，一层一层的剥开），还有可能要经过 Netfilter 防火墙（属于内核的模块）的过滤，最终达到 Web 程序，最终建立了 TCP/IP 的连接。

**TCP连接如图所示：**
<img src="https://pic1.zhimg.com/80/v2-00b0304761d7856b4a84f3fc0e25d184_1440w.jpg">

建立了 TCP 连接之后，发起一个 http 请求。一个典型的 `http request header` 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和DELETE丶HEAD 和 OPTION 以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST请求。客户端向服务端发起 http 请求的时候，会有一些请求信息，请求信息包括三个部分：
- **请求行：请求方法URI协议/协议**
- **请求头（Request Header）**
- **请求正文**

一个完整的HTTP请求例子 
```js
GET/samp.jspHTTP/1.1
Accept:image/gif.image/jpeg,*/*
Accept-Language: Keep-Alive
Host: localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate

username=jinqiao&password=1234
```

**注意：最后一个请求头之后是空行，发送回车符和换行符，通知服务器以下不再有请求头。**

- 请求的第一行是“方法URL协议/版本”：GET/sample.jsp HTTP/1.1 
- 请求头（Request Header）请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。
```js
Accept:image/gif.image/jpeg,*/*
Accept-Language: Keep-Alive
Host: localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate
```
- 请求正文：请求头和请求正文之间是有关空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文可以包含客户端提交的查询字符串信息：
```js
username=jinqiao&password=1234
```


## 4. 服务器永久重定向响应

服务器给浏览器响应有关 301 永久重定向响应，这样浏览器就会访问 `http://www.google.com/` 而非 `http://google.com/`

为什么浏览器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像 `www.yy.com` 和`yy.com`，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而减低排名。而搜索引擎知道 301 永久重定向是什么意思，这样就会把访问带 www和不带 www 的地址归到同一个网址排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。


## 5. 服务器处理请求

经过前面的重重步骤，我们终于将我们的 http 请求发送到服务器这里，其实前面的重定向已经是到达服务器了，那么服务器是怎么处理我们的请求呢？

后端会在固定的端口接收到 TCP 报文开始，它会对 TCP 连接进行处理，对 HTTP 协议进行解析，并按照报文格式进一步封装成 HTTP Request 对象，供上层使用。

一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。

此时客户端不是直接通过 HTTP 协议访问某些网站应用服务器，而是先请求到 Nginx，Nginx 再请求应用服务器，然后将结果返回给客户端，这里 Nginx 的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其它服务器正常运行，就不会影响用户使用。

<img src="https://pic4.zhimg.com/80/v2-d0d4569842a1269dae1ab711d0955af3_1440w.jpg">

通过 Nginx 的反向代理，我们到达了 Web 服务器，服务器脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等，当然这个过程涉及很多后端脚本的复杂操作。由于对这一块不熟，所以这一块只能介绍这么多了。


## 6. 服务器返回一个 HTTP 响应

结果前面的步骤，服务器收到我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个 HTTP 响应。

HTTP响应 和 HTTP请求相似，HTTP 响应也由 3 个部分构成，分别是：
- 状态行
- 响应头（Request Header）
- 响应正文

```js
HTTP/1.1 200 OK
Date: Sat, 31 Dec 2005 35:59:59 GTM
Content-Type: text/html;charset=ISO-8859-1
Content-length: 122

<html>
    <head>
        <title>http</title>
    </head>
    <body>
        <!-- body goes here -->
    </body>
</html>    
```

**状态行：** 由协议版本丶数字形式的状态码丶以及相应的状态描述，各元素之间以空格分割

> 格式：HTTP-Version Status-Code Reason-Phrase CRLF 例如 HTTP1.1 200 OK

-  协议版本：是用 http1.0 还是其它版本
- 状态码：状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。
- 状态描述：状态描述给出了关于状态代码的简短的文字描述，比如说状态为200时的描述为OK


**响应头：**

- **响应头部：** 由关键字/值组成，每行一对，关键字和值用英文冒号“:”分割，典型的响应头有

|      应答头       | 说明                                                         |
| :---------------: | :----------------------------------------------------------- |
|       Allow       | 服务器支持哪些请求方法（如GET丶POST等）                      |
| Content-Enconding | 文档的编码（Encode）方法。只有在解码之后才可以得到 Content-Type 头指定的内容类型。利用 gzip 压缩文档能够显著地减少文档的下载时间。Java 的 GZIPOutputStream 可以很方便地进行 gzip 压缩，但只有 Unix上的 Netscape 和 Window 上的 IE4丶IE5 才支持它。因此，Servlet 应该通过查看 Accept-Encoding 头（即request.getHeader("Accept-Enconding")）检查浏览器是否支持 gzip，为支持 gzip 的浏览器返回经 gzip 压缩的HTML 页面，为其他浏览器返回普通页面。 |
|  Content-Length   | 表示内容长度，只有当浏览器使用持久 HTTP 连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStream，完成后查看大小，然后把该值放入 Content-Length 头，最后通过byteArrayStream.writeTo(response.getOutpputStream()) 发送内容 |
|   Content-Type    | 表示后面的文档属于 MIME 类型。Servlet 默认 text/plain，但通常需要显示地指定为 text/html。由于经常要设置 Content-Type，因此HttpServletResponse 提供一个专用的方法 setContentType |
|       Date        | 当前的 GMT 时间。你可以用 setDataHeader 来设置这个头以避免转换时间格式的麻烦。 |
|      Expires      | 应该在什么时候认为文档已经过期，从而不再缓存它               |
|   Last-Modified   | 文档的最后改动时间。客户可以通过 if-Modifined-Since 请求头提供应该日期，该请求头被视为一个条件 GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个 304（Not Modified）状态。Last-Modified 也可用 setDateHeader 方法来设置 |
|     Location      | 表示客户应当去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，改方法同时设置状态代码为302 |
|      Refresh      | 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader("Refresh", "5;URL=http://host/path")让浏览器读取指定的页面。注意这种功能通常是设置HTML页面HEAD区的<META HTTP-EQUIV="Refresh" CONIENT="5;URL="http://host/path">实现，这是因为自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写十分重要。但是，对于Servlet来说直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或者访问指定页面”，而不是“每隔N秒刷新本页面或者访问指定页面”。因此，连续刷新要求每次都发送Refresh头，而发送 204 状态代码则可以阻止浏览器连续刷新，不管是使用Refresh头更加方便还是<META HTTP-EQUIV="Refresh"...> 注意Refresh头不属于HTTP1.1正式规范的一部分，而是一个拓展，但Netscape和IE都支持它 |
|      Server       | 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 |
|    Set-Cookie     | 设置和页面关联的Cookie。Servlet不应使用response.setHeader("Set-Cookie", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。 |
| WWW-Authenticate  | 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个 头是必需的。例如response.setHeader("WWW-Authenticate",BASIC realm=\"executives"\"")。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess） |



**响应正文：** 包括我们需要的一些具体信息，比如cookie丶html丶image，后端返回的请求数据等等这里需要注意，响应正文和响应头之间有一行空格，表示响应头的信息到空格为止，
<img src="https://pic2.zhimg.com/80/v2-04877a972afac867987ab3fb2b314449_1440w.jpg">


## 7. 浏览器显示 HTML

在浏览器没有完全接受全部 HTML 文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样，这里我们只介绍 webkit 的渲染过程，下图对应的就是WebKit渲染的过程，这个过程包括：

> 解析html以构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树

**浏览器在解析html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。** 在解析过程中，如果遇到请求外部资源时，如图片丶外部的CSS丶iconfont等，请求是异步的，不会影响html文档进行加载

解析过程中，浏览器会**首先解析HTML文件构建DOM树，然后解析CSS文件渲染树，等到渲染树完成后，浏览器开始布局渲染树并将其绘制到屏幕上。** 这个过程比较复杂，涉及到两个概念：**reflow(回流) 和 repaint(重绘)。**

**DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为reflow（重排）**；**当盒模型的位置，大小以及其它属性，如颜色丶字体等确定下来之后，浏览器便开始绘制内容，这个过程称为repain（重绘）**。

页面在首次加载时必然会经历 reflow 和 repain。reflow 和 repain 过程是非常消耗性能的，尤其是在其移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少 reflow 和 repain。

当文档加载过程中遇到 JS 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中的 JS 文件加载完毕，还要等解析执行完毕，才可以恢复html 文档的渲染线程。因为 JS 有可能会修改 DOM，最为经典的domcument.write，这意味着在 JS 执行完成前后续所有资源的下载可能是没有必要的，这是 JS 阻塞后续资源下载的根本原因。所以我平时的代码中，JS 是放在文档末尾。

**JS 的解析器是由浏览器的 JS 解析器引擎完成的，** 比如谷歌的是V8。JS 是单线程运行，也就是说在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，比如 IO 读写等，所有需要一种机制可以先执行排在后面的任务，这就是：同步任务和异步任务。

**JS的执行机制就可以看做是一个主线程加上一个任务队列。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈；异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行先依次运行执行栈，然后会从任务队列中提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环。**

### PS： 异步加载 JavaScript

JS 加载的缺点：加载工具方法没法阻塞文档，过多的 JS 加载会影响页面效率，一旦网速不好，那么整个网站都将等待 JS 加载而不进行后续等渲染工作

目的：有些工具方法需要按需加载，用到再加载，不用不加载

**JavaScript 异步加载的三种方案**

- defere 异步加载：但要等到 dom 文档全部解析完成才会被执行，只有 IE 能用（执行时不阻塞页面加载 支持IE） => DOMContentLoad 事件可以监测到

- async 异步加载：加载完就执行，async只能加载外部脚本，不能把 JS 写在 script 标签里面（执行时不阻塞页面加载）

- 创建 script，插入到 DOM，加载 callback

         function loadScript(url, callback) {
             var script = document.createElement('script'),
                 script.type = "text/javaScript";
             if(script.readyState) { // IE
                 if(script.onreadystatechange === 'complete' || script.onreadystatechange === 'loaded') {
                     callback();
                 }
             }else { // 非IE
                 script.onload = function() {
                     callback();
                 }
             }
             script.url = url;
             document.head.appendChild(script);
         }


## 8. 浏览器发送请求获取嵌入在 HTML 中的资源（如图片丶音频丶视频丶CSS丶JS等等）

其实这个步骤可以并列在步骤7中，在浏览器显示 HTML 时，它会注意到需要获取其它地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。比如我要获取外图片丶CSS丶JS文件等，类似于下面的链接：

这些地址都要经历一个和 HTML 读取类似的过程，所以浏览器会在 DNS 中查找这些域名，发送请求丶重定向等等

不像动态页面，静态文件会允许浏览器对齐其进行缓存，有的文件可能会不需要与服务器通讯，而从缓存中直接读取或者放在 CSDN 中。






# 6. TCP 有哪些手段保证可靠交付？

**TCP 是一种面向连接的丶可靠的字节流服务。**

## 面向连接： 

**意味着两个使用 TCP 的应用（通常是一个客户端和一个服务器），在彼此交换数据之前必须建立一个 TCP 连接。在一个 TCP 连接中，仅有的两方进行彼此通信。广播和多播不能用于 TCP。**


- **将数据截断为合理的长度：** 应用数据被分割成 TCP 认为最合适发送的数据块。这和 UDP 完全不同，应用程序产生的数据报长度将保持不变。
- **超时重发：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
- **对于收到的请求，给出确认响应：** 当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。（之所以推迟，可能是要对包做完整校验）
- **校验包有错，对齐报文段，不给出响应，TCP 发送数据端，超时会重发数据：** TCP 将保持它的首部和数据的校验和。这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。（希望发端超时并重发）
- **对失序数据进行重新排序，然后交给应用层：** 既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此此 TCP 报文段的到达也可能会失序。如果必要，TCP 将收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。
- **对于重复数据，能够丢失重复数据：** 既然IP数据会发生重复，TCP的接收端必须丢弃重复的数据。
- **TCP 还能提供流量控制：** 如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免丢失，控制发送者的发送速度，使得接收者来得及接收。这就是流量控制。流量控制根本目的是为了防止分组丢失，它是构成 TCP 可靠性的一方面。

## PS：流量控制知识点

### 如何实现流量控制？

由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议保证了分组无差错丶有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小控制发送方的数据发送。

### 流量控制引发的死锁？怎么避免死锁的发生？

**当发送者收到了一个窗口为 0 的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为 0 的应答在传输过程中丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就互相等待，从而产生死锁。**

为了避免流量控制引发的死锁，TCP 使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为 0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免死锁的产生。

### 拥塞阻塞和流量控制的区别？

- 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；
  - 常用的方法就是：
    - 慢开始丶拥塞避免
    - 快重传丶快恢复
- 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。

### 拥塞算法的控制

我们再开始假定：1. 数据是单方向传递，另一个窗口只发送确认 2. 接收方的缓存足够大，因为发送方的大小由网络的拥塞长度来决定。

#### 慢开始算法

发送方维持一个叫做拥塞窗口 vwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞长度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑接收方地接收能力，发送窗口可能小于拥塞窗口。

慢开始算法地思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小

这里用报文段的个数作为拥塞窗口的大小举例说明慢开始算法，实际的拥塞窗口是以字节为单位，如下图：

<img src="https://pic2.zhimg.com/v2-54715533f093170d50f1ff1be39006e9_r.jpg">

从上图可以看到，一个传输轮次所经历的时间其实就是往返时间 RTT，而且没经过一个传输轮次（transmission round），拥塞窗口 cwnd 就加倍。

为了防止 cwnd 增长过大引起网络拥塞，还需设置一个慢开始门限 ssthresh 状态变量。

ssthresh的用法如下：当 cwnd < ssthresh 时，使用慢开始算法

当 cwnd > ssthresh 时，改用拥塞避免算法

当 cwnd == ssthresh，慢开始与拥塞避免算法任意

注意，这里的“慢”并不是指 cwnd 的增长速率慢，而是指在 TCP 开始发送报文段时先设置 cwnd = 1，然后逐渐增大，这当然比按照的 cwnd 一下子把许多报文段突然注入到网络中要“慢得多”。

#### 拥塞避免算法：

拥塞避免算法让拥塞窗口缓慢增长，即每经过一次往返时间 RTT 就把发送方得拥塞窗口 cwnd 加 1，而不是加倍。注意拥塞窗口按线性规律缓慢增长。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认，虽然没有收到确认可能是其它原因得分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限 ssthresh 设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器由足够时间把队列中积压的分组处理完毕。

整个拥塞控制的流程如下图：

<img src="https://pic3.zhimg.com/80/v2-f7db63b1f00cbd8170e1435616e06216_720w.jpg">

- 拥塞窗口 cwnd 初始化为 1 个报文段，慢开始门限初始值为 16
- 执行慢开始算法，指数规律增长到第 4 轮，即 cwnd = 16 = ssthresh，改为执行拥塞避免算法，拥塞窗口按线性规律增长
- 假定 cwnd = 24 时，网络出现超时（拥塞），则更新后的 ssthresh = 12，cwnd 重新设置为 1，并执行慢开始算法。当 cwnd = 12 = ssthresh 时，改为执行拥塞避免算法

关于乘法减少（Multiplicative Decrease）和加法增大（Additive Increase）

“乘法减少”指的是无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限 ssthresh 设置为出现拥塞时的发送窗口大小的一半，并执行慢开始算法，所以当网络频繁出现拥塞时，ssthresh 下降的很快，以大大减少注入到网络中的分组数。“加法增大”是指执行拥塞避免算法后，使拥塞窗口缓慢增大，以防止过早出现拥塞。常合起来成为 AIMD 算法。

注意：“拥塞避免”并非完全能够避免了拥塞，而是使网络比较不容易出现拥塞。

#### 快重传算法：

快重传要求接收方在收到一个时序的报文段就立即发出重复确认（为的是使发送方早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据捎带确认。快重传算法规定，发送方只要一接收到三个重复确认就应当立即重传对方尚未收到的报文段，而不被继续等待设置的重传计时器时间到期。如下图：

<img src="https://pic3.zhimg.com/80/v2-c72fce5494ca8ee12244189430f12cea_720w.jpg">

#### 快恢复算法：

快重传配合使用的还要快恢复算法，有以下两个要点：

- 当发送方连续收到三个重复确认时，就执行”乘法减少“算法，把 ssthresh 门限减半（为了预防网络发生拥塞）。但是接下去并不执行慢开始算法

- 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 减半后的指，然后执行拥塞避免算法，使 cwnd 缓慢增大。如下图，TCP Reno 版本是目前使用最广泛的版本。

  <img src="https://pic4.zhimg.com/80/v2-5f4034bc11c3a48a1d1a115f9ee0259b_720w.jpg">

注意：在采用快恢复算法时，慢开始算法只是在 TCP 连接建立时和网络出现超时时才使用

**字节流服务：** 两个应用程序通过 TCP 连接交换 8bit 字节构成的字节流。TCP 不在字节流中插入记录标识符。我们称之为字节流服务

TCP 对字节流的内容不作任何解释： TCP不知道传输的数据。字节流是二进制数据，还是ASCII字符丶EBCDIC字符或者其它类型数据。对字节流的解释由TCP连接双方的应用层解释。





# 7. 如何应对流量劫持？

**流量劫持划分为3大部分：DNS劫持丶数据劫持丶劫持监控。**

## 1. DNS劫持
是互联网的一种攻击方式，通过攻击 DNS 服务器或者伪造 DNS 服务器方法，把目标服务器网站域名解析到错误地方，让用户无法正常访问真正的地址。

**DNS是如何工作的？**

客户端访问服务端的时候，首先要根据域名对应的 IP 地址，这一步要在 DNS 服务器进行获取。请求 DNS 服务器的时候，需要通过 UDP 协议去寻找当地网络的运营商提供的公共域名服务器中差找 IP。如果没有找到，就会继续请求上级域名服务器进行处理，一直到返回IP为止。

域名劫持，即使是在请求 DNS 解析域名服务器出现的时候，目标服务器被恶意解析到其它 IP 地址，造成用户无法正常使用服务。

**为了减少 DNS 查询时间，HTTP 协议栈中会缓存域名解析**

- 浏览器可能会缓存域名解析
- 用户系统中的域名映射表（hosts）会缓存域名解析
- 公共域名服务器通常由 ISP（互联网服务商）提供，公共域名服务器会缓存上一级域名服务器的结果，公共域名服务器 TTL 到期后，会向顶级服务器获取信息。

**如何污染DNS？**
- 篡改 Hosts 文件
- 污染中间链路设备（路由器等）
- 修改 UDP 内容，影响DNS查询的结果
- 入侵 DNS 服务器（成本高）

**如何抵御 DNS 劫持？**

解决域名劫持的一个方法就是绕开安全性比较差的 UDP 协议，通过访问一个可信的源头来解析域名，解析方式不需要拘泥于 UDP 协议，也可以通过 HTTP 协议。
- 在 TLS 协议之上传输 DNS 内容
- 用 HTTP 协议来传输 DNS
- 用 HTTPS 协议来传输 DNS
- 使用自己维护的DNS服务器（成本高）

## 2. 数据劫持

**数据劫持最基本针对明文传输的内容发生。用户发起 HTTP 请求，服务器返回页面时候，经过中间的运营商网络，页面内容的篡改或者内容加塞，强行插入弹窗或者广告**

**如何抵御数据劫持？**

- 目前行业内解决的方法是对内容进行 HTTPS 加密，实现密文传输，彻底避免劫持问题。
- MD5 检验同样能起到数据劫持的作用，MD5 校验是指内容返回前，应用层对返回的数据进行校验，生成校验值。同时内容接收方收到内容后，也对内容进行校验，同样生成校验值，将这校验值进行对比，倘若一致，则证明判断数据无劫持。

**注意：HTTPS 也能被运营商劫持**

- 伪造证书，通过病毒或者其它方式将伪造证书的根证书安装在用户系统中（较少）
- 代理也有客户的证书和秘钥，或者客户端与代理认证的时候不校验合法性，即可通过代理来与我们服务端进行数据交互（较多）。

**下面说几款对数据劫持起到监控作用，但是并不能对劫持后的页面进行修复**
- **Content-Security-Policy(CSP)：实质就是白名单，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。**
  - 指定每种资源类型可以加载执行的条件
  - 还可以防御 XSS 攻击
  - 也可以用强迫资源使用 HTTPS 加载，降低劫持可能性
  
  两种方式开启CSP
  ```js
  // 提供 HTTP 头信息
  Content-Security-Policy: default-src https:
  
  // 通过 meta 标签
  <meta http-equiv="Content-Security-Policy" content="default-src https:">
  ```

  **缺点：**
  - 由于 CSP 标识本身存在于 HTML 标签或者 HTTP 请求头中，可以被攻击者可以直接移除掉
  - 规则比较复杂
  - 影响动态创建脚本的使用
- **Subresource Integrity(SRI)**
  - 将使用 base64 编码过后的文件哈希值写入你所用的 script 或 link 标签的 integrity 属性值中即可启用子资源完整性功能
  - 如果校验不成功，则不会执行对应的 script 或 link 内容
  ```js
  <script crossorigin="anonymous" integrity="sha256-+Ec97...E" src="https://a.com"></script>
  ```
  **缺点：**
  - 由于 SRI 标识本身存在于 HTML标签中，可以被攻击者直接移除掉
  - 影响动态创建脚本的使用
  - 校验失败时影响可用性
  - 兼容性有限，IOS Safari不支持

## 3. 劫持监控
**参考美团点评 2018 前端分享上的防治方案**
- 方案A：在某些省份丶地区自建监测站，定期抓取固定资源（资源太固定，检测站数量也远远不够）


## 如何应对流量劫持？
**总结：面对 Web 流量劫持，首先我们可以在网站层面限制读取权限，限制恶意代码的写入，其次可以通过公有 DNS 和 HttpDNS 来防止恶意 DNS 劫持。全站开启 HTTPS，加密数据传输，可以有效防止数据泄露，同时解决流量劫持的问题。**

- **限制网站权限：** 部分网站遭遇劫持主要是非法服务器，获取了 Web 网站文件及文件夹的读取权限，针对这个问题，我们可以利用服务器的安全设置丶提高网站程序的安全性，已此防范 Web 劫持。
- **提升网站 防 SQL 注入功能：** SQL 注入通过利用 SQL 语言的特性， 向 Web 数据库写入内容，获取权限，因此我们需要针对 MS SQL Server 数据库中的小权限 sa 默认用户，建立一个只能访问本系统数据库的专一用户，并且为他配置最小权限。
- **配置 Web 站点文件夹及操作权限：** 使用 Windows 系统中的超级管理员权限对 Web 站点文件和文件夹进行权限配置。将大部分的权限配置为仅读权限，黑客在没有写权限的情况下，很难将木马程序植入，减少网站域名劫持的可能性。
- **定期清理 Web 网点中存在的可疑文件：** 不管黑客通过何种方式读取权限，在事件管理器中都会显示出异常情况，通过对异常事件和日期分析，查看执行代码文件中是否被注入代码或改动，并且对新增可执行代码进行清理。
- **使用公共114DNS：** 让用户绕过运营商 local NDS，使用 114 DNS（国内最大的中立缓存DNS），这种在技术实现上有比较大的难度，成本也比较高。在现在的情况下即使用户使用公共 DNS，也并不能完全解决问题。先不论公共 DNS 是否也有在做劫持，最关键的是，运营商也会针对到公共 DNS 的流量做劫持。对于流量入口的把握，运营商不会放松警惕。
- **HttpDNS，防止 DNS 劫持：** 
  - 在移动客户端中加入一个域名解析模块，客户端通过 HTTP 的方式向网站的流量调度服务器请求 IP，流量调度服务器会根据用户所在位置给用户一个最优的 IP。客户端在获取 IP 后直接用此 IP 来访问所需站点资源。
  - 网站本身使用 HttpDNS 面临较高的成本，而通过又拍云提供的 HttpNDS 调度功能，可以最低成本的方式，有效防止 DNS 劫持。 
    <img src="https://pic3.zhimg.com/80/v2-6bf94ff85c0aaefcb75edf7e5bda3a7a_720w.png">
- **HTTPS 防劫持：** 由于公共 DNS丶HttpDNS的部署成本过高，有一定的技术难度，并且在面对无孔不入的流量劫持时难度会有力有不逮。这时候网站开启 HTTPS 作为防劫持手段之一可以高效的解决这些问题。目前绝大部分网站也都已经启用 HTTPS 来加密。HTTPS协议就是 HTTP + SSL/TLS，在HTTP的基础上加入 SSL/TLS 层，提供了内容加密丶身份加密和数据完整性三大功能，最终目的就是为了加密数据，用于安全的数据传输。

  **HTTP请求过程：** 
  <img src="https://pic4.zhimg.com/80/v2-f323a576b1a25e0f84fd5e36f663016f_720w.png">

  **HTTPS请求过程:**
  <img src="https://pic1.zhimg.com/80/v2-f748f8fdd33b80c599efef81c9a8a178_720w.png">

  HTTPS请求流程
  - SSL 协议在 HTTP 请求中增加了握手阶段，并且对明文 HTTP 请求丶应答进行加密。SSL 握手阶段，客户端浏览器会进行服务器身份认证，确认客户端证书属于该目标网站并且证书有效的时候，并且通信双方还会使用一个加密和解密的会话秘钥。
  - 在 SSL 握手阶段结束之后，服务端和客户端通过会话秘钥对交互数据进行加密/解密操作，将HTTP请求和应答经过加密之后才会发送到网络上。
  - 通过 SSL 协议对 Web 服务器的身份认证，使流量劫持导致的连接错误情况被发现和终止，保证流量劫持无法实现。同时 HTTPS 在数据传输中对数据进行加密传输，保证数据不被窃听以及修改。 
- **如何快速启用 HTTPS：** 鉴于启用 HTTPS 会带来一定的服务器资源消耗，目前大多数公司普遍的选择是直接使用国内的 CDN 服务，比如又拍云提供一站式 HTTPS服务，简单几步就能完成全站 HTTPS 的部署，光是免费类证书就有2款，而付费证书在3-5天内即可完成申购。另外一种可以直接在 Web 服务器上部署证书和秘钥，可以去网站查看教程。






# 8. DNS 解析流程
## 1. 检查浏览器缓存中是否缓存过该域名对应的 IP 地址
- 用户通过浏览器浏览过某网站之后，浏览器就会自动缓存过该网站域名对应的地址，当再次访问的时候，浏览器就会从缓存中查找该域名对应的IP地址，因为缓存不仅是有大小限制，而且还有时间限制（域名被缓存的瞬间通过属性来设置），所以存在域名对应的找不到的情况。
- 当浏览器从缓存中找到了该网站对应的地址，那么整个解析过程结束，如果没有找到，将进行下一步骤。对于的缓存时间问题，不宜设置太长的缓存时间，时间太长，如果域名对应的发生变化，那么用户将在一段时间内无法正常访问到网站，如果太短，那么又造成频繁解析域名。

## 2. 如果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP
如果第一个步骤没有完成对域名的解析过程，那么浏览器会去缓存系统中查找系统是否缓存过这个域名对应的地址，也可以理解为系统自己也具有域名解析的基本能力。在系统中，可以通过设置文件夹来将域名手动绑定到某上，文件位置在。对于普通用户，并不推荐自己手动绑定域名，对于开发者来说，通过绑定域名可以轻松切换环境，可以从测试环境切换到开发环境，方便开发和测试。在系统中，黑客经常修改他的电脑的文件，将用户常常访问的域名绑定它指定的上，从而实现了本地解析，导致这些域名被劫持。或者在系统中。

## 3. 向本地域名解析服务器系统发起域名解析的请求
如果在本机上无法完成域名的解析，那么系统只能请求本地域名解析系统进行解析，本地域名一般都是本地区的域名服务器，比如你连接的校园网，那么域名解析系统就是在你的校园机房内，如果你连接的是电信丶移动或者联通的网络，那么本地域名解析服务器就是在本地区，由各自的运营商提供服务。对于本地服务器地址，系统使用命令就可以查看，在系统下直接使用命令来查看服务器地址。一般都缓存了大部分的域名解析的结果，当然缓存时间也受域名失效时间控制，大部分的解析工作到这里就差不多已经结束了，负责大部分的解析工作。

## 4. 向根域名解析服务器发起域名解析请求
本地域名解析器还没有完成解析的话，那么本地域名解析服务器将向根域名服务器发起解析请求

## 5. 根域名解析服务器发起域名解析请求
本地域名解析向根域名服务器发起解析请求，根域名服务器返回的是所查域的通用顶级域地址，常见的通用顶级域有...等

## 6. 向顶级域名（gTLD）服务器发起解析请求
本地域名解析服务器向顶级域名服务器发起请求

## 7. 顶级域名服务器接收请求并返回 Name Server 服务器
服务器接收本地域名服务器发起的请求，并根据需要解析的域名，找到该域名对应的域名服务器，通常情况下这个服务器就是你注册的域名服务器，那么你注册的域名的服务商的服务器将承担起域名解析的任务。

## 8. Name Server服务器返回IP地址给本地服务器
服务器查找域名对应的地址，将地址连同值返回给本地服务器。

## 9. 本地域名服务器缓存解析结果
本地域名服务器缓存解析后的结果，缓存时间由时间控制。

## 10. 返回解析结果给用户
解析结果将直接返回给用户，用户系统将缓存地址，缓存时间由来控制，至此解析过程结束。






# 9. HTTP 状态码
**HTTP 状态码负责表示客户端HTTP请求的返回结果丶标记服务器的处理是否正常，丶通知出现的工作错误等。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现的了错误**

| 状态码 | 类别                           | 描述                   |
| ------ | ------------------------------ | ---------------------- |
| 1xx    | informational(信息状态码)      | 接受请求正在处理       |
| 2xx    | Success(成功状态码)            | 请求正常处理完毕       |
| 3xx    | Redirection(重定向状态码)      | 需要附加操作已完成请求 |
| 4xx    | Client Error(客户端错误状态码) | 服务器无法处理请求     |

| 状态码 | 状态码中文名称         | 中文描述                                                                                                                                                         |
| ------ | ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 200    | OK                     | 请求成功                                                                                                                                                         |
| 204    | No Content             | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档。                                                                       |
| 206    | Partial Content        | 是对资源某一部分的请求，服务器成功处理了部分GET请求，响应报文中包含由Content-Range指定范围的实体内容。                                                           |
| 301    | Moved Permanently      | 永久性重定向。请求的资源已被永久性的移动到新的URI，返回信息会包括新的URI，浏览器会自动重定向到新的URI。今后任何新的请求都应使用新的URI代替。                     |
| 302    | Found                  | 临时重定向。与301类似。但资源只会临时被移动。客户端应继续使用URI                                                                                                 |
| 303    | See Other              | 查看其它地址。与302类似。使用GET请求查看                                                                                                                         |
| 304    | Not Modified           | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望返回在指定日期之后修改的资源。 |
| 307    | Temporary Redirect     | 临时重定向。与302类似。使用GET请求重定向，会按照浏览器标准，不会从POST变成GET。                                                                                  |
| 400    | Bad Request            | 客户端请求报文中存在语法错误，服务器无法理解。浏览器会像 200 OK 一样对待该状态码                                                                                 |
| 401    | Unauthorized           | 请求要求用户的身份认证，通过HTTP认证（BASIC认证丶DIGEST认证）的认证信息，若之前已进行一次请求，则表示用户认证失败                                                |
| 402    | Payment Required       | 保留，将来是要                                                                                                                                                   |
| 403    | Forbidden              | 服务器理解请求客户端的请求，但是拒绝执行此请求                                                                                                                   |
| 404    | Not Found              | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置“你所请求的资源无法找到”的个性页面。也可以在服务器拒绝请求且不想说明理由时使用         |
| 500    | Internal Serverl Error | 服务器内部错误，无法完成请求，也可能是Web应用存在Bug或某些临时故障                                                                                               |
| 501    | Not Implemented        | 服务器不支持请求的功能，无法完成请求                                                                                                                             |
| 503    | Service Unavailable    | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中                                                              |






# 10. HTTP 缓存策略
**HTTP 缓存策略只是为了解决客户端和服务端信息不对称的问题而存在的，客户端为了加快速度会缓存部分资源。因为下次请求时，客户端不知道这个资源有没有更新，服务端也不知道客户端缓存的是哪个版本，不知道该不该再返回资源，其实就是一个消息同步问题，HTTP缓存策略就是来解决这个问题。**

**HTTP 缓存机制要点如下：** HTTP 缓存机制分为强制缓存和协商缓存两类

- 强制缓存的意思是不要问了，直接用缓存吧。
  - 强制缓存的常见技术有 **Expires** 和 **Cache-control** 
  - **Expires** 的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求
  - **Cache-Control** 有很多属性，常见的属性 **max-age** 设置了缓存有效的时间长度，单位为秒，这个时间没有到，都不用发起请求。
  - **immutable** 也是 **Cache-Control** 的一个属性，表示这个资源这辈子都不用请求了，但是它兼容性不好，
  - **Cache-Control** 的 **max-age** 优先级比 **Expires** 高
- 协商缓存常见的技术有 **ETag** 和 **Last-Modified**
  - **Etag** 其实就是给资源算一个 **hash** 值或者版本号，对应的常见为 **request header** 为 **if-None-Match**
  - **Last-Modified** 其实就是加上资源修改的时间，对应的常见 **request header** 为 **if-Modified-Since**
  - **Etag** 每次修改都会改变，而 **Last-Modified** 的精度只到秒，所以 **Etag** 更精确，优先级更高，但是服务端开销更大。

**强制缓存 和 协商缓存 都存在的情况下，先判断强制缓存是否生效，如果生效不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。 **

### 11-1. ETag 和 If-None-Match
Etag 是 URL 的 Entity Tag，就是一个 URL资源的标识符，类似文件的 MD5，计算方式也类似，当服务器返回时，可以根据返回内容计算一个 hash 值或者就是一个数字版本号，具体返回什么值要看服务器的计算策略。然后把它加到 response 的 header 里面，可能长这样
```js
Etag: 741a708e6d4c22386861a2cafd590ed0
```
客户端拿到后会将这个 Etag 和返回值一起存下来，等下次请求时，使用配套的 if-None-Match，将这个放到 request 的 header 里面，可能长这样。
```js
If-None-Match: 741a708e6d4c22386861a2cafd590ed0
```
然后服务端拿到请求里面的 If-None-Match 跟当前版本的Etag比较下：
- 如果是一样的话，直接返回 304，语义是 Not Modified，不返回内容（body），只返回 header，先告诉浏览器直接使用缓存。
- 如果不一样，返回 200 和最新内容

与 Etag 配套的还有一个不太常用的 request header --- If-Match，这个和前面 If-None-Match 的语义是相反的。前面 If-None-Match的语义是如果不匹配就下载。
而 If-Match 通常用于 post 或者 put 请求中，语义为如果匹配才提交，比如你在编辑一个商品，其它也可能同时在编辑。当你提交编辑时，其它人可能已经先于你提交了，这时候服务端的 Etag 就已经变了，If-Match 就不成立了，这时候服务端会给你返回 412 错误，也就是 Precondition Failed，前提条件失败。如果 If-Match 成立，就正常返回 200。


### 11-2. Last-Modified 和 If-Modified-Since
Last-Modified 和 If-Modified-Since 也是配套使用的，类似于 Etag 和 If-None-Macth的关系。只不过 Etag 放的是一个版本号或者 hash 值，Last-Modified 放的是资源的最后修改时间。Last-Modified 是放到 response 的 header 里面的，可能长这样的
```js
Last-Modified: Wed, 21 Oct 2000 07:28:00 GMT
```
而客户端浏览器在使用时，应该将配套的 If-Modified-Since 放到 request 的 header 里面，长这样：
```js
If-Modified-Since: Wed, 21 Oct 2000 07:28:00 GMT
```
服务端拿到这个头后，会跟当前版本的修改时间进行比较：
- 当前版本的修改时间比这个晚，也就是这个时间又改过了，返回 200 和新的内容
- 当前版本的修改时间和这个一样，也就是没有更新，返回 304，不返回内容，只返回头，客户端直接使用缓存。

与 If-Modified-Since 对应的还有 If-Unmodified-Since，If-Modified-Since 可以理解为有更新才下载，那 If-Unmodified-Since 就是没有更新才下载。如果客户端传了 If-Unmodified-Since，像这样：
```js
If-Unmodified-Since: Wed, 21 Oct 2000 07:28:00 GMT
```
服务端拿到这个头后，也会跟当前版本的修改时间进行对比：
- 如果这个时间后没有更新，服务器返回 200，并返回内容
- 如果这个时间后有更新，其实是这个 If 不成立，会返回错误代码 412，语义为 Precondition Failed

### 11-3. Etag和Last-Modified优先级
Etag 和 Last-Modified 都是协商缓存，都需要服务器进行计算和比较，那如果这两个都存在，用哪个呢？答案是 Etag, Etag 的优先级比 Last-Modified 高。因为Last-Modified 在设计上有个问题，那就是 Last-Modified 的精度只能到秒，如果一个资源频繁修改，在同一秒进行多次修改，你从 Last-Modified 上是看不出区别的。但是 Etag 每次修改都会生成新的，所以它比 Last-Modified 精度高，更准确。但是 Etag 也不是完全没问题的，你的 ETag 如果设计为一个hash值，每次请求都要计算这个值，需要额外耗费服务器资源。具体使用哪一个，需要根据自己的项目情况来进行取舍。

****

### 11-4. Expires
Expires 比较简单，就是服务器的 response 的 header 带上这个字段
```js
Expires: Wed, 21 Oct 2000 07:28:00 GMT
```
然后在这个时间前，客户端浏览器都不会发起请求，而是直接使用缓存资源

### 11-5. Cache-Control
Cache-Control相对比较复杂，可设置属性也比较多，max-age 只是其中一个属性，长这样：
```js
Cache-Control: max-age=20000
```
这表示当前资源在2000秒内都不用再请求了，直接使用缓存了。

immutable 也是 Cache-Control 的一个属性，但是是个试验性质的，各个浏览器兼容不好的。设置了Cache-Control: immutable表示这辈子都用缓存了，再请求是不可能的了。

no-cache: 使用缓存前，强制要求把请求提交给服务器验证（协商缓存验证）

no-store: 不存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存

### 11-6. Expires 和 Cache-Control的优先级
如果在 Cache-Control 响应头设置了 max-age 或者 max-age之类，那么 Expires 头会被忽略

# 11. HTTP 强行使用UDP能实现吗？ 
HTTP 是状态的协议，即可以基于 TCP 也可以基于 UDP，不过大部分实现是基于 TCP 的。使用 TCP，不用考虑数据包乱序，丢失这些问题，实现起来更简单丶高效。

都可以，但是一般没人用 UDP 方式，因为 UDP 的不可靠传输加上 HTTP 的无记忆应答方式，那就是最糟糕的组合。举例就是你发送 http 请求访问网站，结果UDP 给你丢了你还傻傻不知道 UDP 给你耍了。

# 12. GET 和 POST 请求区别 
**当人们问起 GET 和 POST 的区别时，我们要先确定，这里的 GET 和 POST 是基于什么前提的？**
get用来获取数据，post用来提交数据
get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节），而post无限制。
get请求的数据会附加在url之 ，以 " ？ "分割url和传输数据，多个参数用 "&"连接，而post请求会把请求的数据放在http请求体中。
get是明文传输，post是放在请求体中，但是开发者可以通过抓包工具看到，也相当于是明文的。
get请求会保存在浏览器历史记录中，还可能保存在web服务器的日志中

## 13-1. 如果什么前提都没有，也就是不用任何规范限制的话，我们只考虑语法来说这两个方式没有任何区别的，只有名字不一样。
## 13-2. 如果是基于 RFC 规范的，那么是基于 RFC 的理论还是 RFC 的具体实现
### 13-2-1. 如果是基于 RFC 理论的，我们称之为 Specification。那么 GET 和 POST 是具有相同的语法，GET 方式用作获取信息，POST 方式用作发送信息。
### 13-2-2. 如果是基于 RFC 的具体实现的，我们称之为 implementation。其实要区分是具体的哪一种实现。我们通常默认指的是浏览器实现的 RFC。当然不止浏览器，我们任何人都可以设计一种 HTTP 协议的接口，使用 RFC 规范，当然这些都是我们不用考虑的，因为并不通用。

- GET 的数据在 URL 中对所有人都是可见的。POST的数据不会显示在 URL 中**

- GET 对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL的最大长度是 2048 个字符）。POST是无限制的。**
- GET 可收藏为书签，POST 不可收藏为书签。**
- GET 编码类型 `application/x-www-form-url`，POST 编码类型`encodeapplication/x-www-form-urlencoded`或`multipart/from-data`。为二进制数据使用多重编码。**
- GET 历史参数会保留在浏览器历史中。POST 参数不会保存在浏览器历史中。**
- GET 只允许 ASCII 字符。POST 没有限制。也允许二进制数据。**
- 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或者其他敏感信息时绝不要使用 GET！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或者 Web服务器日志中。**

# 13. HTTP的请求报文和响应报文由几个部分组成

一个请求报文由请求行丶请求行丶空行和请求数据组成

# 14. OSI七层 

| OSI七层网络模型         | TCP/IP四层概念模型 | 对应网络协议                            |
| ----------------------- | ------------------ | --------------------------------------- |
| 应用层（Applicaion）    | 应用层             | HTTP，TFTP，FTP，NFS，WAIS，SMTP        |
| 表示层（Presentation）  | 应用层             | Telnet，Rlogin，SNMP，Gopher            |
| 会话层（Session）       | 应用层             | SMIP，DNS                               |
| 传输层（Transport）     | 传输层             | TCP，UDP                                |
| 网络层（Network）       | 网络层             | IP，ICMP，ARP，RARP，AKP，UUCP          |
| 数据链路层（Data Link） | 数据链路层         | FDDI，Ethernet，Arpanet，PDN，SLIP，PPP |
| 物理层（Physical）      | 数据链路层         | IEEE 802.1A,IEEE 802.2 到 IEEE 802.11   |

## OIS模型各层地基本作用：

- 应用层：为应用程序提供网络服务
- 表示层：数据格式化，加密，解密
- 会话层：建立，维护，管理会话连接
- 传输层：建立，维护，管理端到端连接
- 网络层：IP 寻址和路由选择
- 数据链路层：控制网络与物理层之间通信
- 物理层：比特流传输





# 15. websocket 在项目中的用途，握手过程

- 有了 HTTP 协议为什么还需要 websocket 协议？因为 HTTP 协议有个缺陷，通信只能由客户端发起。

举例来说，我们想了解今天的天气，只能是客户端向服务端发出请求，服务端返回查询结构。HTTP 协议做不到服务器向客户端推送消息。

<img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017051507.jpg">

这种单向请求的特点，注定了如果服务端有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询“；每隔一段时间，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。

轮询的效果低，非常浪费资源（因为不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法

websocket 协议在2008年诞生的，2011 年成为国际标准。所有浏览器都已经支持了。

- 它的最大特点是，服务器可以向客户端推送消息，客户端也可以向服务器发送消息，是真正的双向平等对话，属于服务端推送技术的一种。

<img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017051502.png">

## 其它特点：

- 建立在 TCP 协议之上，服务器端的实现也比较容易。

- 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 43，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能提供各种 HTTP 代理服务器

- 数据格式比较轻量，性能开销小，通信搞笑

- 没有同源限制，客户端可以与任意服务器通信

- 协议标识符 ws（如果加密，则为 wss），服务网址就是 URL

  ```js
  wx://example.com:80/some/path
  ```

  <img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017051503.jpg">

## 示例：

```js
var ws = new WebSocket("wss://echo.websoket.org"); // 客户端和服务端进行连接

ws.onpen = function(evt) {
    console.log("Connect open ...");
    ws.send("Hello WebSockets!");
};

ws.onmessage = funtion(evt) {
    console.log("Received Message:" + evt.data);
    wx.close();
}

ws.onclose = function(evt) {
    console.log("Connect closed");
}
```

readyState 属性返回实例对象的当前状态，共有四种：

- CONNECTING：值为0，表示正在连接
- OPEN：值为1，表示连接成功，可以通信了
- CLOSING：值为2，表示连正在关闭
- CLOSED：值为3，表示连接已经关闭，或者打开连接失败

下面是一个示例：

```js
switch(ws.readyState) {
    case WebSocket.CONNECTING:
        // do something
        break;
    case WebSocket.OPEN:
        // do something
        break;
    case WebSocket.CLOSING:
        // do something
        break;
    case WebSocket.CLOSED:
        // do something
        break;
    default:
        // this never happens
        break
}
```

## 使用场景

- 多个用户之间进行交互
- 需要频繁地向服务端请求更新数据

比如弹幕丶消息订阅丶多玩家游戏丶协同编辑丶股票基金实时报价丶视频会议丶在线教育等需要高实时地场景。





# 16. CDN加速原理

## 什么是 CDN？

CDN 的全称是（Content Delivery Network），即内容分发网络。其目的是通过在现有的 Internet 中增加一层新的 CACHE（缓存）层，将网站的内容发布到最接近用户的网络“边缘”的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。从技术上全面解决由于网络宽带小丶用户访问大丶网络分布不均等原因，提高用户访问网站的响应速度。

简单的说，CND 的工作原理就是将你源站的资源缓存到位于全球各地的 CDN 节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回您的源站获取，避免网络拥塞丶缓解源站压力，保证用户访问资源的速度和体验。

<img src="https://upload-images.jianshu.io/upload_images/6534548-6530631dca814f8b.png?imageMogr2/auto-orient/strip|imageView2/2/w/638/format/webp">

**CDN 对网络的优化作用主要体现在如下几个负面**

- 解决服务端的“第一公里”问题
- 缓存甚至消除了不同运营商之间互联的瓶颈造成的影响
- 减轻了各省的出口宽带压力
- 缓解了骨干网的压力
- 优化了网上热点内容的发布

## CDN 工作原理

### 传统访问过程

<img src="https://upload-images.jianshu.io/upload_images/6534548-7c8899afcd671a0c.png?imageMogr2/auto-orient/strip|imageView2/2/w/618/format/webp">

**由上图可见，用户访问未使用 CDN 缓存网站的过程为：**

- 用户输入访问的域名，操作系统向 LocalDns 查询域名的 IP 地址
- LocalDns 向 RootDns 查询域名的授权服务器（这里假设 LocalDns 缓存过期）
- RootDns 得到域名授权 dns 记录回应给 LocalDns
- LocalDns 得到域名的授权 dns 记录后，继续向域名授权 dns 查询域名的 IP 地址
- 域名授权 dns 查询域名记录后，回应给 LocalDns
- LocalDns 将得到的域名 IP 地址，回应给用户端
- 用户得到域名 IP 地址后，访问站点服务器
- 站点服务器应答请求，将内容返回客户端

### CDN 访问过程

<img src="https://upload-images.jianshu.io/upload_images/6534548-eaabc85f59942d23.png?imageMogr2/auto-orient/strip|imageView2/2/w/903/format/webp">



**通过上图，我们可以了解到，使用了 CDN 缓存后的网站的访问过程变为：**

- 用户输入访问的域名，操作系统向 LocalDns 查询域名的 IP 地址
- LocalDns 向 ROOT DNS 查询域名的授权服务器（这里假设 LocalDns 缓存过期）
- ROOT DNS 将域名授权 DNS 记录回应给 LocalDns
- LocalDns 得到域名的授权 DNS 记录后，继续向域名授权 DNS 查询域名的 IP 地址
- 域名授权 DNS 查询域名记录后（一般是 CNAME），回应给 LocalDns
- LocalDns 得到域名记录后，向智能调度 DNS 查询域名的 IP 地址
- 智能调度 DNS 根据一定的算法和策略（比如静态拓扑丶容量等），将最适合的 CDN 节点 IP 地址回应给 LocalDns
- LocalDns 将得到的域名 IP 地址，回应给用户端
- 用户得到域名 IP 地址后，访问站点服务器
- CDN 节点服务器应答请求，将内容返回给客户端（缓存服务器一方面在本地进行保存，以便以后使用，二方面把获取的数据返回给客户端，完成数据服务过程）

通过以上的分析我们可以得到，为了实现对用户透明（使用缓存后用户客户端无需进行设置）访问，需要使用 DNS（域名解析）来引导用户来访问 Cache 服务器，以实现透明的加速服务，由于用户访问网站的第一步就是域名解析，所以通过修改 DNS 来引导用户访问是最简单有效的方式。

### CDN 网络的组成元素

对于普通的 Internet 用户，每个 CDN 节点就相对于一个放置在它周围的网站服务器，通过对 DNS 的接管，用户的请求被透明地指向离他最近的节点，节点中 CDN 服务器会像网站的原始服务器一样，响应用户的请求，由于它离用户更近，因而响应时间必然更快。

从上面图中 虚线 圈起来的那块，就是 CDN 层，这层是位于 用户端 和 站点服务器 之间

- 智能调度 DNS（比如 f5 的 3DNS）

  只能调度 DNS 是 CDN 服务中的关键系统，当用户访问加入 CDN 服务的网站时，域名解析请求将最终由“智能调度DNS” 负责处理。它通过一组预先定义好的策略，将当时最接近用户的节点地址提供给用户，使用户可以得到快速的服务。同时它需要与发布在各地的 CDN 节点保持通信，跟踪各节点的健康状态丶容量等信息，确保将用户的请求分配到就近可用的节点上。

- 缓存功能服务
  - 负载均衡设备（如 lvs，F5 的 BIG/IP）
  - 内容 Cache 服务器（如 squid）
  - 共享存储

## 名词解释

### CNAME记录（CNAME record）

CNAME 即别名（Canonical Name）,可以用来把一个域名解析到另一个域名，当 DNS 系统在查询 CNAME 左面的名称的时候，都会转向 CNAME 右面的名称再进行查询，一直追踪到最后的 PTR 或 A 名称，成功查询后才会做出回应，否则失败。

例如，你有一台服务器上存放了很多资料，你使用 docs.example.com 去访问这些资源，但又希望通过 document.example.com 也能访问到这些资源，那么你就可以在你的 DNS 解析服务商添加一条 CNAME 记录，将 document.example.com 指向 docs.example.com，添加该条 CNAME 记录后，所有访问 document.example.com 的请求都会被转到 docs.example.com，获得相同的内容。

### CNAME 域名

接入 CDN 时，在CDN 提供商控制台添加完加速域名后，你会得到一个 CDN 分配的 CNAME 域名，你需要在你的 DNS 解析服务商添加 CNAME 记录后，将自己的加速域名指向这个 CNAME 域名，这样该域名所有的请求才会都将转向 CDN 的节点，达到加速效果。

### DNS

DNS 即 Domain Name Systen，是域名解析服务器的意思。它在互联网的作用是：把域名转换成为网络可以识别的 IP 地址。人们习惯记忆域名，但机器间互相只认 IP 地址，域名与 IP 地址之间是一一对应的，它们之间的转换工作称为域名解析，域名解析需要专门的域名解析服务器完成，整个过程是自动进行的。比如：上网时输入 www.baidu.com 会自动转换成 220.181.112.143

常见的 DNS 解析器服务商：阿里云解析，万网解析，DNSPod，新网解析，Route53（AWS），Dyn，Cloudflare等

回源 host

回源 host：回源 host 决定回源请求访问到源站上的具体某个站点

- 例子1：源站是域名源站为 www.a.com，回源 host 为 www.b.com，那么实际回源是请求到 www.a.com 解析到的 IP，对应的主机上的站点 www.b.com
- 例子2：源站是 IP 源站为 1.1.1.1，回源 host 为 www.b.com，那么实际回源的是 1.1.1.1 对应的主机上的站点 www.b.com

### 协议回源

指回源时使用的协议和客户端访问资源时的协议保持一致，即如果客户端使用 HTTPS 方式请求资源，当 CDN 节点上未缓存该资源时，节点会使用相同的 HTTPS 方式回源获取资源；同理如果客户端使用 HTTP 协议的请求，CND 节点回源时也使用 HTTP 协议。





# 17. DNS 解析会出现错误吗，为什么？

DNS 解析出现错误，就是把一个域名解析成一个错误的 IP 地址，或者根本不知道某个域名对应的 IP 地址是什么时，我们就无法通过域名访问相应的站点了，这就是 DNS 解析故障。出现 DNS 解析故障最大的症状就是访问站点对应的 IP 地址是没有问题，然而访问他的域名就会出现错误。

## 判断是否出现 DNS 解析故障的方法

点击开始 -> 运行 -> 输入 CMD 后回车，输入 "nslookup" 回车，再输入你的域名，如果出现 DNS request time out，timeout was 2 seconds 的提示信息，则说明 DNS 确实出问题了，如果 DNS 解析正常的话，会反馈正确的 IP 地址。

## 解决 DNS 解析错误的方法

**更换本地 DNS 的方法**

目前国内电信运营商通过使用 DNS 劫持的方法，干扰用户正常上网，使得用户无法访问（例如弹出广告窗口），所以我一直在使用 GoogleDNS，不仅可以解决中国的电信运营商的流氓行为，还可以解决域名无法访问的情况。

小技巧：点击开始 -> 设置 -> 网络连接 -> 本地连接 -> 属性 -> TCP/IP协议 -> 使用下面的 DNS 服务器地址，在框中输入 8.8.8.8 和 8.8.4.4 断开，重新连接网络即可，并且没有电信丶联通（原网通）等DNS 劫持问题。

**修改 HOST 文件的方法**

如果我们希望把某个域名与某个 IP 绑定，就可以通过修改 HOSTS 文件的办法：”开始 -> 搜索“，然后查找名为 hosts 的文件。或路径为 c:window systyem32 drivers etc 都可。用记事本打开，在下面加入要解析的 IP 和 域名 即可。（修改 HOSTS 文件则是在实在没有办法的时候再用）。

小知识：每个 windows 系统都有个 HOSTS 文件，它的作用是加快域名解析，方便局域网用户，屏蔽网站，顺利连接系统等功能。

**清除 DNS 缓存信息的方法**

开始 -> 运行 -> 输入CMD，在 ipconfig/? 中有一个名为 /flushdns 的参数，这个就是清除 DNS 缓存信息的命令，执行 ipconfig/flushdns 命令，当出现 "successfullyflushednsresolvercache" 的提示时就说明当时计算机的缓存信息已经被成功清除。接下来所有的 DNS 缓存都会重新加载。

小知识：DNS 解析就是把你的域名解析成一个 IP 地址，服务商提供的 DNS 解析就是把你的域名解析成相应 IP 地址的服务器主机，这就是 DNS 域名解析。




# 18. http请求的方法有哪些
  https://segmentfault.com/a/1190000040449935
  http://hchuafang.com/zatan/53.html