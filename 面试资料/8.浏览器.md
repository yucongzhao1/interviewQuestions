# 1. 介绍Chrome浏览器几个版本

> Chrome 浏览器提供了 4 种发布版本，即`稳定版(Stable)`丶`测试版(Beta)`丶`开发者版(Dev)`和`金丝雀版(Canary)`。虽然Chrome 这几个版本名称各不相同，但都沿用了相同的版本号，只是更新早晚的区别。就好比 IOS 等系统，测试版本可以率先更新到 IOS 12 并进行测试，不断改进稳定后，正式版才升级到 12 版本。Chrome 也是如此，更新最快的金丝雀版会领先正式版 1-2 版本

## Canary(金丝雀)版

- 只限于用于测试，Canary 是 Chrome 的未来版本，是功能丶代码最先进的 Chrome 版本，一方面软件本身没有足够时间测试，另一方面网页也不一定支持这些全新的功能，因此极不稳定。好在，谷歌将其设定为可独立安装丶与其他版本的 Chrome 程序共存，因此适合进阶用户安装备用，尝鲜最新功能。这种不稳定性使得 Chrome 版目前不适合日常使用。
- Chrome Canary 是更新速度最快的 Chrome 版本，几乎每天更新。它相当于支持自动更新丶并添加了谷歌自家服务与商业闭源插件（Flash等）Chromium，更强大好用。

## 开发版(Dev)

- Chrome Dev 最初是以`Chromium`为基础丶更新最快的 Chrome，后来则被 Canary 取代。Dev 版每周更新一次，虽然仍不太稳定，但已经可以勉强满足日常使用，适合 Web 开发者用来测试性功能和网页
- 让 IT 人员使用开发板，开发者可以通过开发版测试自己公司的应用，确保这些应用能与 Chrome 最新的API更改及功能更改兼容。注意：开发者版并非百分之百稳定，但开发者可以提前 9 至 12 周体验将添加到 Chrome 稳定版的功能

## 测试版(Beta)

- Chrome Beta 以 Dev 为基础，每月更新一次。它是正式版发布前的最后测试版本，所有功能都以在前面几个版本中得到测试并改进，因此十分稳定，普通用户也可以用来日常使用
- 让 5% 的用户使用测试版，测试版用户可以提前 4-6 周体验即将在 Chrome 稳定版推出的功能。测试版用户可以发现特定版可能存在的问题，让您可以先解决问题，然后再向所有用户推出该版本。

## 稳定版(Stable)

- 最后的 Chrome Stable 就是我们熟知的正式版，它以 Beta 为基础，几个月更新一次。由于所有的功能都已经过数个月反复测试，是稳定性最高的 Chrome 版本
- 让大多数用户使用稳定版，稳定版是已经进行充分测试的版本，稳定版每2-3周会进行一次小幅度更新，并且每6周会进行一次重大更新。

所以要定期下载开发者版，体验 Chrome 最新的 API 和新功能，发现自己的应用跟新 API 和新功能的是否有兼容问题，找到开发亮点。

对于Chrome的历史版本测试，可以使用 Docker Selenium 做分布式自动化测试，部署多个重大关注的版本，进行自动化测试，对比差异。



# 2. 点击一个按钮，浏览器会做些什么？

- 点击按钮后创建一个 Event 实例
- 然后把事件放在事件队列中，让它等候处理
- Event 循环线程处理这个事件
- 沿着 DOM 路径找到触发事件的元素
- 如果这个元素上有处理这个事件的默认行为，并且要在DOM事件处理阶段周期之前执行，就执行它的默认行为
- 捕获阶段
- 目标阶段
- 冒泡阶段
- 如果这个元素上有处理这个事件的默认行为，并且要在 DOM 事件处理阶段周期之后执行，就执行它的默认行为   



# 3. 说一下浏览器解析Html文件的过程

#### 详细发生过程
**1.创建DOM树**

将HTML转换成浏览器能理解的结构 --- DOM树
- HTML词法丶语法分析
  - 词法分析：把字符流初步解析成我们可理解的“词”，学名为token
  - 语法分析：把开始结束标签配对丶属性赋值好丶父子关系连接好丶构成dom树
- 请求JS丶CSS
**2.样式计算（Recalculate Style）**
- 把CSS转换成浏览器能理解的结果 ——  styleSheets
- 转换成样式表中的属性值，将其标准化
- 计算出DOM树中每个节点的具体样式
  - CSS继承，包含父节点的样式
  - 样式层叠的规则：!important无限高>内联1000>id 100 > class 10 > tag > 继承 > 浏览器默认
  **3.布局阶段** 
- 创建布局树Layout treee，构建一棵只包含可见元素布局树，不可见元素都不包含
- 布局计算
**4.**

#### 通俗理解
- 解析 HTML:
  - 通过字节流把内容传到 html 解析引擎，解析引擎首先会调用解析器处理标签，处理没闭合或使用不规范的标签，处理完毕后交给分词器处理。
  - 分词器将标签转换成 token，并交给 dom 构建器处理。
  - 在解析过程中遇到 script 会暂停解析，直到 script 加载完成并执行完，html 才会解析
- 构建 dom 树
  - 将 token 解析为 dom 节点，并将 dom 节点添加到dom树中。
  - 通过压栈出栈方式构建 dom 树。
  - 这个过程就是逐行解析代码，包括 html 标签和 js 动态生成的标签，最终生成 dom 树
- css 树
  - 在解析的过程中，遇到 css资源需要加载的时，html解析不会暂停。
  - 当css资源下载好，会调用css解析引擎去解析CSS代码，计算出最终的样式数据。
  - 对于CSS代码中非法的语法它会直接忽略掉。
  - 解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设定，用户设置，外链样式，内联样式，html中的style。
  - 在解析CSS的同时，构建树被暂停，直到CSS树解析完成
- 渲染树
  - 把之前构建好的 CSS 树以及 DOM 树按照一定的规则以及依赖关系生成渲染树，写到内存，等待进一步生成界面。
  - 渲染树和 DOM 树是由区别的。
  - DOM 树完全和 html 标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如 head丶display:none 的元素等。
- 布局
  - 从渲染树的根节点开始遍历，然后确定每个节点对象页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。
  - 同时把每个节点做成一个纹理，放在gpu寄存器管理。
- 绘制
  - 遍历渲染树，调用渲染器的paint()方法在屏幕上显示        



# 4. 浏览器缓存

## 一丶浏览器缓存策略

> 浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需要向服务器发起HTTP请求，将缓存过程划分为两个部分：强缓存和协商缓存，强缓存优先于协商缓存。
- 强缓存：服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略
- 协商缓存：让客户端与服务器之间能实现缓存文件是否更新的验证丶提升缓存的复用率，将缓存信息中 Etag 和 Last-Modified 通过请求发送给服务器，由服务器校验，返回 304 状态码时，浏览器直接使用缓存


HTTP 缓存都是从第二次请求开始的：
- 第一次请求资源时，浏览器返回资源，并在 response header 中回传资源的缓存策略
- 第二次请求时，浏览器判断这些请求参数，击中 强缓存 直接 200，否则就把请求加到 request header 中传给服务器，看看是否击中协商缓存，击中则返回 304，否则浏览器会返回新的资源。

<img src="https://camo.githubusercontent.com/df822872ee2a8aef44c665f8fffd13c4cc4eb637bd8706ce4899e8eb72d2a431/687474703a2f2f696d672d7374617469632e796964656e6778756574616e672e636f6d2f77786170702f69737375652d696d672f7169642d382e706e67">

### 强缓存
#### Expires
- 该字段是服务器响应消息头字段，告诉浏览器在过期时间之前可以直接从浏览器缓存中存取数据
- Expires 是 HTTP1.0 的字段，表示缓存到期时间，是一个绝对值（到期时间+缓存时间）。在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。
- 由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。此外，即使不考虑修改，时差或者误差等因素也可能造成客户端和服务端的时间不一致，导致缓存失效。

**优势特点：**

- HTTP1.0 产物，可以在 HTTP1.0 和 1.1 中使用，简单易用
- 以时刻标识失效时间

**劣势问题：**

- 时间是由服务器发送的（UTC），如果服务器时间和客户端时间存在不一致，可能会出现问题。
- 存在版本问题，到期之前的修改客户端是不可知的。

#### 强缓存 cache-control 

已知 Expires 的缺点之后，在 HTTP/1.1 中，增加了一个字段 Cache-control，该字段表示资源缓存中的最大有效时间，在该时间内，客户端不需要向服务端发送请求。

**这两者的区别就是前者是绝对时间，而后者是相对时间。**

**cache-control 常用字段：**

- **max-age：**即最大有效时间
- **must-relalidate：**如果超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。
- **no-cache：**不使用强缓存，需要与服务器验证缓存是否新鲜
- **no-store: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。
- public:所有内容都可以被缓存（包括客户端和代理服务器，如CDN）
- private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。

Cache-control的优先级高于Expires，为了兼容HTTP/1.0和HTTP1.1，实际项目中两个字段都可以设置。该字段可以在请求头或者响应头设置，可组合使用多种指令：
- 可缓存性
  - public：浏览器和缓存服务器都可以缓存页面信息
  - private：代理服务器不可缓存，只能被单个用户缓存。默认值。
  - no-cache：浏览器和服务器都不应该缓存页面信息，但仍可缓存，只是在缓存前需要向服务器确认资源是否被更改。可配置private，过期时间设置为过去时间
  - only-if-cache：客户端只接受已缓存的响应
- 到期
  - `max-age=<seconds>`:缓存存储的最大周期，超过这个周期被认为过期
  - `s-maxage=<seconds>`：设置共享缓存，比如can。会覆盖max-age和expires
  - `max-stale[=<seconds>]`：客户端愿意接收一个过期的资源
  - `min-fresh=<seconds>`:客户端希望在指定的时间内获取最新的响应
  - `stale-while-revalidate=<seconds>`：客户端愿意接收陈旧的响应，并且在后台一部检查新的响应。时间代表客户端愿意接收陈旧响应的时间长度。
  - `stale-if-error=<seconds>`：如新的检测失败，客户端则愿意接收陈旧的响应，时间代表等待时间。
- 重新验证和重新加载
  - must-revalidate: 如页面过期，则去服务器进行获取
  - proxy-relavidate:用于共享缓存
  - immutable:响应正文不随时间改变
- 其他
  - no-store：绝对禁止缓存
  - no-transform:不得对资源进行转换和转变。例如，不得对图像格式进行转换。

优势特点：
- HTTP1.1产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题
- 比Expires多了很多选项设置。

劣势问题：
- 存在版本问题，到期之前的修改客户端是不可知的


#### 协商缓存
- 协商缓存的状态码由服务器决策返回200或者304
- 当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了`if-Modifined-Since`或者`if-None-Match`时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回304状态，加载浏览器缓存，并且响应头会设置`Last-Modified`或者`Etag`属性。
- 对比缓存在请求数上和没有缓存是一致的，但如果是304的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此，在响应体体积上的节省它的优化点。
- 协商缓存有2组字段（不是两个），控制协商缓存的字段有：`Last-Modified/Last-Modified-since(htpp1.0)`和`Etag/if-None-match(http1.1)`
- `Last-Modified/if-Modifined-since`表示的是服务器的资源最后一次修改的时间；`Etag/if-None-match`表示的是服务器资源的唯一标识，只要资源变化，Etag就会重新生成。
- `Etag/If-None-match`的优先级比`Last-Modified/If-Modified-since`高


**Last-Modifined/if-Modifiend-since**
- 服务器通过`Last-Modified`字段告知客户端，资源最后一次被修改的时间，例如 `Last-Modified:Mon,10 Nov 2018 09:10:11 GMT`
- 浏览器将这个值和内容一起记录在缓存数据库中
- 下一次请求相同资源时，浏览器  从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头的`Last-Modified`的值写入请求头的`if-Modified-Since`字段
- 服务器会将`if-Modified-Since`的值与`Last-Modified`字段进行对比，响应  304；反之，则表示修改了，响应200状态码，并返回数据。

优势特点：
- 不存在版本问题，每次请求都会去服务器进行校验。
- 服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容 

劣势问题：
- 只要资源修改，无论内容是否发生实质性的变化，都会将资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。
- 以时刻作为标识，无法识别一秒内进行多次修改的情况。如果资源更新的速度是以秒以下单位，那么该缓存是不能被使用的，因为它的时间最低是秒。
- 某些服务器不能精确的得到文件的最后修改时间。
- 如果文件是通过服务器动态生成的，那么该方法的更新永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。

**Etag/If-None-match**   
- 为了解决上诉问题，出现了一组新的字段`Etag`和`If-None-Match`
- `Etag`存储的是文件特殊标识（一般是hash生成的），服务器存储文件的`Etag`字段。之后的流程和`Last-Modifined`一致，只是`Last-Modified`字段和它所表示的更新时间变成了`Etag`字段和它所表示的文件hash，把`if-Modified-Since`变成了`If-None-Match`。服务器同样进行比较，命中返回304，不命中返回新资源和200。
- 浏览器在发起请求时，服务器返回在`Response header`中返回请求资源的唯一标识。在下一次请求时，会将上一次返回的`Etag`值赋值给`if-No-Matched`并添加在`Request Header`中。服务器将浏览器传来的`if-No-matched`跟自己的本地的资源`Etag`做对比，如果匹配，则返回304通知浏览器读取本地缓存，否则返回200和更新后的资源。
- Etag的优先级高于Last-Modified 

优势特点
- 可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况
- 不存在版本问题，每次请求都回去服务器进行校验

劣势问题：
- 计算`ETag`值需要性能损耗
- 分布式服务器存储的情况下，计算`ETag`的计算如果不一样，到导致浏览器从一台服务器上获得页面内容后到另一台服务器上进行验证时出现`ETag`不匹配的情况。

#### 二丶 浏览器出现from disk丶from memory的策略
强缓存：服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行其它缓存策略。
- 浏览器  发现缓存无数据，于是发送请求，向服务器获取资源
- 服务器响应请求，返回资源，同时标记资源的有效期Cache-Control:max-age=3000
- 浏览器缓存资源，等待下次重用。    



# 5. 浏览器都有哪些进程，渲染进程中都有哪些线程？

<img src="https://pic4.zhimg.com/v2-d03ca0b5f361b88fbadbfa036a5f72df_b.png">

### 浏览器组成  
- 早期浏览器是单进程架构，由于单进程会导致卡死，容易崩溃等原因。现代浏览器就有了多进程架构，将来会是面向服务架构。
- 基本的多进程架构进程有：`浏览器主进程`，`渲染进程`，`GPU进程`，`网络进程`，其它`插件进程`等。
- `每个页面或同站点`将分配一个`渲染进程`。`渲染进程`由`多个线程`相互协同的。
- `渲染进程`组成：`渲染主线程`丶`JS引擎线程`丶`IO线程`丶`定时器线程`，`事件触发线程`等


### 浏览器进程
- **浏览器主进程**  

  负责包含地址栏，书签栏，前进后退按钮等部分的工作
- **渲染进程**

  负责一个tab内关于页面呈现的所有事情  

- **GPU进程**  

  负责处理GPU相关的任务
- **网络进程**  

  负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问
- **其它插件进程**  

  负责控制一个网页用到的所有插件，如flash

### 渲染进程中都有哪些线程？

- **GUI渲染线程**
  - 负责渲染浏览器界面，解析HTML丶CSS丶 构建DOM树丶RenderObject树丶布局和绘制等
  - 当界面需要重绘或者由于某种操作引发回流时，该线程就会执行
  - 注意：GUI引擎线程和JS引擎线程是互斥的，JS引擎线程优先级高于GUI渲染引擎，当JS引擎执行时GUI线程会被挂起，GUI更新后会保存在一个队列中等到JS引擎空闲时间立即被执行  
- **JS引擎线程** 
  - 也称为`JS内核`，负责`处理和解析JavaScript脚本程序`，运行代码，如V8引擎
  - JS引擎一直等待`这任务队列中的任务`，然后`加以处理`，render进程中永远只有一个JS线程在运行JS程序
  - 同样注意：`GUI渲染线程`和`JS引擎线程`是`互斥`，`JS执行时间很长`，就会造成`页面的渲染不连贯`，导致`页面渲染加载阻塞`。
- **事件触发线程**   
  - 归属于`浏览器`而不是JS引擎，用来`控制事件循环`
  - 当JS引擎执行代码块如：`setTimeout`丶`鼠标点击`丶`Ajax异步请求`，会将`对应的任务`添加到`事件进程`中
  - 当`对应的时间服务触发条件`时，该线程会把`事件`添加到`待处理队列的队尾`
- **定时处理线程**
  - `setInterval`与`setTimeout`所在的线程
  - `浏览器定时计数器`并不是有`JavaScript引擎`计数的，它是通过`单独线程`来计时并触发定时
  - 注意：W3C在HTML标准中规定，要求setTimeout中`低于4ms`的时间间隔算为`4ms`
- **异步http请求线程** 
  - 在`HTMLHttpRequest`在连接后通过浏览器新开一个线程请求
  - 将检测到`状态变更时`，如果设置有`回调函数`，`异步线程`就会产生`状态变更事件`，将这个`回调`再放入`事件队列`中，再由`JavaScript引擎`执行。

