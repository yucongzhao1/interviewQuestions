## web安全
- 分类
  - 私密性：不被非法获取和利用
  - 可靠性：不丢失丶不损坏丶不被篡改
- 攻击类型
  - XSS(Cross-Site Scripting)(跨站脚本攻击)
  - CSRF(跨站请求伪造)
  - SQL注入
  - 点击劫持
  - 中间人攻击
 - WEB安全问题
   - 用户身份被盗用
   - 用户密码被泄漏
   - 用户资料被盗取
   - 网站数据库泄漏   






## 1. 跨站脚本攻击(Cross-Site Scripting)
### 定义:

- 是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到web页面中去。使得别的用户访问都会执行相应的嵌入代码。
- 从而盗取用户资料，利用用户身份进行某种动作或者对访问者进行病毒式侵害的一种攻击方式。

### 攻击类型：
- **反射型**
  - 把用户输入的数据"反射"给浏览器端，这种攻击方式需要攻击者诱使用用户点击一个恶意链接，或者提交一个表单或者进入一个恶意网站，注入脚本进入会被攻击者的网站，可以获取用户隐私数据（如cookie）的脚本。 
- **存储型 **  
  - 把用户输入的数据存储在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种XSS攻击具有很强的稳定性。
  - 场景：攻击者在论坛上写下一篇包含恶意 JavaScript 文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在它们的浏览器中执行这段恶意的JavaScript代码。
- **基于DOM**
  - 通过恶意脚本修改页面的DOM结构，是纯粹发生在客户端的攻击。  

### XSS防御：
- 过滤转义字符
  ```js
  function filterXss(str){
      var s = "";
      if(str.length == 0) {
          return "";
      }
      s = str.replace(/&/g,"&amp;");
      s = s.replace(/</g,"&lt;");
      s = s.replace(/>/g,"&gt;");
      s = s.replace(/ /g,"&nbsp;");
      s = s.replace(/\'/g,"&#39;");
      s = s.replace(/\"/g,"&quot;");
      return s; 
  }
  
  ```
- 在cookie中设置 HttpOnly 属性，使得 JS  脚本无法读取 cookie 信息，防止劫取Cookie。  
- CSP内容安全策略   




## 2. 跨站请求伪造（Cross-site request forgery, CSRF）
### 攻击原理：
- 用户登录 A网站
- A网站 确认身份，给客户端 Cookie
- 用户在没有退出 A网站 的情况下，访问 B网站
- B网站 页面向 A网站 发起一个请求
- 根据 网站B 的请求，浏览器带着产生的 Cookie 访问 网站A 

### 防御方法：
- **GET 请求不对数据进行修改**
- **不让第三方网站访问到用户的 Cookie**
  **SameSite：**可以对 Cookie 设置 SameSite 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程序减少跨站请求伪造，但是该属性目前并不是所有浏览器都兼容了。 
- **防止第三方网站请求接口**
  **Refere验证：**通过验证 Refere 来判断该请求是否是第三方网站发起的，在后台接到请求的时候，可以通过请求头中的 Refere 请求头来判断请求来源。
  **使用场景：** 不仅防范跨站请求伪造，还可以防止图片盗链 
- **请求时附带验证信息，比如 验证码 或者 Token**
  **验证码：**跨站请求伪造攻击往往是在用户不知情的情况下构造了网络请求，而验证码会强制用户必须与应用进行交互，才能完成最终请求。 

  **添加Token验证：**服务器下发一个随机 Token，每次发起请求时将Token携带上，服务器建立拦截器验证Token是否有效。

### 危害：

**利用用户登录态在用户不知情的情况下完成业务请求：**

- 盗取用户资金
- 冒充用户发帖背锅
- 损坏网站名誉  

**跟跨脚本攻击（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。**






## 3. SQL注入
### 定义：

就是通过把 SQL 命令插入到 Web 表单提交 或 输入域名 或 页面请求的查询字符串，后台执行 SQL 语句时直接把前端传入的字段拿来做 SQL 查询。

### SQL注入攻击方法:

- 注入点的不同分类
  - 数字型注入
  - 字符型注入
- 提交方式的不同分类
  - GET注入
  - POST注入
  - COOKIE注入
  - HTTP注入
- 获取信息的方式不同分类
  - 基于布尔的盲注
  - 基于时间的盲注
  - 基于报错的注入     

### 防御：

- 不要使用动态SQL
  - 避免将用户提供的输入直接放入SQL语句中
  - 最好使用准备好的语句和参数化查询，这样更安全。 
- 不要把敏感数据保留在纯文本中
  - 加密存储在数据库中的私有/机密数据
  - 这样可以提供了另一级保护，以防攻击者成功地排出敏感数据。
- 限制数据库权限和特权
  - 将数据库用户的功能设置为最低要求
  - 这将限制攻击者在设法获取权限时可以执行的操作
- 避免直接向用户显示数据库错误
  - 攻击者可以使用这些错误消息来获取有关数据库的信息
- 对访问数据库的Web应用程序使用Web应用程序防火墙（WAF）
  - 这为面向Web的应用程序提供了保护，它可以帮助识别SQL注入尝试
  - 根据设置，它还可以帮助防止SQL注入尝试到应用程序（以及数据库）
- 定期测试与数据交互的Web应用程序
  - 这样做可以帮助捕获可能允许的SQL注入的新错误或回归
- 将数据库更新为最新的的可用修补程序
  - 这可以防止攻击者利用旧版本存在的已知弱点/错误            





## 4. 点击劫持
### 原理：

点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入到自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。

### 代码实现:

```objc
<!DOCTYPE html>
  <html>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <head>
      <title>点击劫持</title>
      <style>
          html,
          body,
          img {
              width: 100%;
              height: 100%;
              margin: 0;
              padding: 0;
          }
          iframe {
              width: 100%;
              height: 100%;
              position: absolute;
              top: -0px;
              left: -0px;
              z-index: 2;
              opacity: 0.3;
          }
          button {
              position: absolute;
              top: 270px;
              left: 1150px;
              z-index: 1;
              width: 90px;
              height: 40px;
          }
      </style>
  </head>
  <body>
      <button>美女图片</button>
      <img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1456290144,154203946&fm=26&gp=0.jpg">
      <iframe src="https://www.baidu.com/" scrolling="no"></iframe>
  </body>
  </html>
```

### 防御方法

- **X-FRAME-OPTIONS：** 是一个 HTTP 响应头，在现代浏览器有一个很好的支持，这个 HTTP 响应头就是为了防御用 iframe 嵌套的点击劫持攻击。

  - DENY：表示页面允许通过 iframe 的方式展示 
  - SAMEOPTIION：表示页面可以在相同域名下通过 iframe 的方式展示
  - ALLOW-FROM：表示页面可以在指定来源的 iframe 中展示
- **JS 防御** 
  
  - 代码实现
    ```objc
    <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <meta http-equiv="X-UA-Compatible" content="ie=edge">
          <title>Document</title>
          <style>    
              body {
                  display: none !important;
              }
          </style>
      </head>
      <body>
          <script>
              
              // console.log(self == top);
              if(self == top) { // window.top是读取窗口的引用    window.top是顶层窗口
                  document.getElementsByTagName('body')[0].style.display = 'block';
              }else {
                  top.location = self.location; //;localtion：该对象包含当前URL信息 拥有多个属性
              }
          
          </script>
      </body>
      </html>
    ```






## 5. 中间人攻击
### 原理：

- 中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让双方认为连接是安全的，但是实际上整个通信都被攻击者控制了。
- 攻击者不仅能获得双方的通信信息，还能修改通信信息。

### 攻击方式

- **DNS 欺骗**
  - DNS 用于把访问域名解析成 IP 地址，使得用户发出的网络请求可以寻找到正确的目标服务器。
  - 攻击者往往可以通过入侵 DNS 服务器 或是 篡改用户本地 hosts 文件，从而截取到用户发出的请求。截取请求以后，根据不同目的，攻击者既可以让用户"误入歧途"，引导用户访问一个假网站，也可以把用户请求依旧转发给目标服务器，仅仅实现监听的目的。 
- **APR 欺骗**
  - 如果说 DNS 欺骗是在广域网中的拦截用户请求，那么 APR 欺骗就是在局域网的拦截用户请求。APR（Address Resolution protocol）地址解析协议，是一种IP地址转换为物理地址的协议。
    - 在局域网中，主机A 想要和 主机B（假设IP是123）通信，不仅需要知道对方的IP，也需要知道对方的 MAC地址。如果 主机A 的 本地ARP缓存表没有主机B 的地址缓存，主机A 就会再向局域网内的所有主机发起广播，请求IP 为 123 的主机。
    - 主机B 收到广播，检查主机的 IP 地址与 主机A 请求中的IP地址一致，就会把自己的MAC地址发回给主机A。主机A 接收到反馈以后，会把主机B的MAC地址存入本地APR缓存表，以便下次直接使用。
  - 如何实现APR欺骗呢？
    - 攻击者利用了APR协议的漏洞，通过局域网内部的一台主机（IP并不是123），冒充主机B，向主机A发送自己的MAC地址。主机A接收到消息以后，无法识别消息是真的来自主机B，还是来自一个冒名顶替者，只能照样把接受到的新MAC地址存入APR缓存表，取代原先的记录。
    - 下一次，当主机A想要向主机B发送请求的时候，会先查询主机的APR缓存表，查出主机B的MAC地址是def（本来应该是abc），结果把请求发送给了主机D。从而向攻击者拦截到了请求信息。
- **代理服务器**  
  - 就是用户在访问网站时所使用的各种代理，比如wifi，比如VPN，比如翻墙工具。这些工具未必都是可靠，有些可能遭到黑客攻击，有些自身就有问题，当用户通过这些代理发送请求的时候，请求信息自然而然就会被劫持。

### 防御：

- **使用 DNSSEC 机制**
  - Domain Name System Security Extensions(DNSSEC)安全拓展，是一系列 DNS 安全认证的机制，可以验证用户访问的站点地址是否有效，解决 DNS 欺骗的问题。
- **使用防火墙和杀毒软件**
  - 在局部网内，发起ARP欺骗的主机往往是中了病毒的机器，从而被黑客控制，因此需要定期查杀病毒。而防火墙可以有效阻挡疑似APR欺骗的消息。 
- **HTTPS**
  - HTTPS 协议是 HTTP协议的基础上增加了 SSL层，SSL 层依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。这样一来，即使攻击者截取用户发出的请求信息，也无法解密信息，更无法篡改信息。
  - 但是并不是说使用了 HTTPS 就可以高枕无忧了，如果你还没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。 






## 额外补充
### 广域网和局域网的区别

- 两者范围不一样
  - 局域网就是在固定的一个地理区域内由2台以上的电脑用网线和其他网络设备搭建而成的一个封闭的计算机组，范围在几千米以内。
  - 广域网是一种地域跨度非常大的网络集合，范围在几十公里到几千公里。
- 两者的IP地址设置不一样
  - 在局域网里面，必须在网络上有唯一的IP地址，这个IP地址是唯一的，在另外一个局域网，这个IP地址仍然能够使用。
  - 广域网上的每台电脑（或其他网络设备）都有一个或多个广域网IP地址，而且不能重复。
- 两者的连接方式不一样
  - 局域网是靠交换机进行连接的
  - 而广域网则是靠路由器将多个局域网进行连接的。  
  
  

### MAC地址 和 IP地址的区别

- 地址长度的不同
  - MAC地址的长度为48位（6个字节），通常表示为12个16进制数，每2个16进制数之间用冒号隔开，如00:50:29:5A:8H:1E就是一个MAC地址。
  - IP地址为32位，由用点分隔开的4个8位组构成，如192.168.0.1就是一个IP地址，这种写法叫点分十进制格式。
- 所在寻址协议层上的区别
  - MAC地址应用在OSI第二层，即数据链路层。数据链路层协议可以使数据从一个节点传递到相同链路的另一个节点上（即MAC地址）。
  - IP地址应用于OSI第三层，即网络层。网络层协议使数据可以从一个网络传递到另一个网络上（APR根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而达到最终目的网络）。
- 分配依据不同
  - MAC地址的分配是基于制造商
    - MAC地址由网络设备商生产时写在硬件内部。这个地址与网络无关，也即无论将带有这个地址的硬件（如集线器丶网卡丶路由器等）接入到网络的何处，它都有相同的MAC地址，是不可变的。 
  - IP地址的分配是基于网络拓扑     
    - IP地址由网络地址和主机地址两部分组成，分配给这两部分的位数随地址数（A类丶B类丶C类等）的不同而不同。 








参考：https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653190473&idx=1&sn=0de112757e14158472e4b9d04ad58b09&chksm=8c990b93bbee828558e532ea1a9c174f565e48c299cd2e1143cae85cf96ca6b2e61317e78fba&scene=21#wechat_redirect