# 1. 微信小程序主要目录和文件的作用
- **project.config.json：**项目配置的文件
- **App.js：**设置一些全局的基础数据等
- **App.json：**底部tab丶标题栏和路由等设置
- **App.wxss：**公共样式丶引入iconfront等
- **pages：**里面包含一个个具体的页面
- **index.wxml：**(WeiXin Markup Language)是框架设计的一套标签语言，结合基础组件丶事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件
- **index.wxss：**(WeiXin Style Sheets)是一套样式语言，用于描述WXML的组件样式
- **index.js：**页面的逻辑处理，网络请求等
- **index.json：**小程序设置，如页面注册，页面标题及tabar





# 2. WXML 和标准的 HTML 的异同？

**相同：**

- 都是用来描述页面的结构
- 都是由标签丶属性等构成

**不相同：**

- 标签名字不一样，且小程序标签更少丶单一标签更多
- 多些 `wx:if` 这样的属性以及 `{{}}` 这样的表达式
- WXML 仅能在微信小程序开发者工具中预览，而 HTML 可以在浏览器内预览
- 组件封装不同，WXML 对组件进行了重新封装
- 小程序运行在 JsCore，没有 DOM 树和 window 对象，小程序中无法使用 window 对象和 document 对象






# 3. WXSS 和 CSS 的异同？
- 都是用来描述页面的样子
- WXSS 具有 CSS 大部分的特性，也做了一些扩充和修改
- WXSS 新增了尺寸单位，WXSS 在底层支持新的尺寸单位`rpx`
- WXSS 仅支持部分 CSS 选择器
- WXSS 支持全局样式与局部样式
- WXSS 没有 `body`, 样式可直接使用 `@import` 导入






# 4. 小程序页面间有哪些传递数据的方法？
- 使用全局变量实现数据传递
- 页面跳转或重定向时，使用 `url` 带参数传递数据
- 使用组件模板 `template` 传递参数
- 使用缓存传递参数
- 使用数据库传递数据






# 5. 微信小程序怎样跟事件传值？
- 给 HTML 元素添加 `data-` 属性来传递我们需要的值，然后通过 `e.currentTarget.dataset` 或 `onload` 的 `param` 参数获取。

- 但是 `data- `名称不能有大写字母和不可以存放对象






# 6. 如何封装微信小程序的数据请求？
- 在根目录下创建 `utils` 目录以及 `api.js` 文件以及 `apiConfig.js` 文件
- 在 `apiConfig.js` 封装基础的`get`丶`post`以及`put`丶`upload`等请求方法，设置请求体，带上 token 和异常处理等
- 在`api` 中引入 `apiConfig.js` 封装好的请求方法。页面数据请求的 `urls`,设置对应的方法并导出
- 在具体的页面中导入






# 7. 简述微信小程序原理？
- 小程序本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口
- 它的架构是数据驱动的架构模式，它的  UI 和 数据 是分离的，所有的页面更新都是需要通过对数据的更改来实现
- 它从技术将和现有的前端开发差不多，采用 `JavaScript` 丶 `WXML` 丶`WXSS` 三种技术进行开发
- 功能可分为 视图层（View） 和 逻辑层（App Service） 两个部分，其中 WXML 模板 和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。
- 视图层 用来展示UI，逻辑层 用来处理业务逻辑丶数据及接口调用
- 两个部分在两个进程中进行，通过系统层 JSBridge 实现通信，实现UI的渲染丶事件的处理等
- 小程序的渲染层和逻辑层分别是由 2 个线程管理；渲染层的界面使用了  WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS 脚本。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程，这两个线程的通信会经过由微信客户端（Native）做中转，逻辑层发送网络请求也经由 Native 转发，小程序的通信模型如下图所示

<img src="https://res.wx.qq.com/wxdoc/dist/assets/img/4-1.ad156d1c.png">






# 8. WXS 语言的作用
微信小程序的架构分为 `app-service` 和 `page-frame`，分别运行在不同的线程。

你开发时写的所有 JS 都运行在 `App Service` 线程里的，而每个页面各自的 WXML/WXSS 则运行在 `page-frame` 中。`app-service `与 `page-frame `之间通过桥协议通信(包括 setData 调用丶canvas 指令和各种 DOM 事件)，涉及消息序列化丶跨线程通信与 evaluateJavaScript()。

## 这种架构的好处是：

- 分开了业务主线程和显示界面。即便业务主线程非常繁忙，也不会阻塞用户在 `page-frame` 上交互。
- 一个小程序可以有多个 `page-frame(webview)`，页面切换动画比 SPA() 更流畅。

## 坏处是：

- 在 `page-frame` 上无法调用业务 JS
- 跨线程通信的成本很高，不适合频繁通信的场景
- 业务 JS 无法直接控制DOM





# 9. 原生开发小程序丶wepy丶mpvue的对比？
- 个人认为，如果是新项目，且没有旧的 H5 ·项目迁移，则考虑使用小程序原生开发，好处是相比于第三方框架，坑少
- 而如果有老的 H5 项目是 Vue 开发或者也有 H5 项目也需要小程序开发，则比较适合 WePy 或者 mpvue 来做迁移或者开发，近期看 wepy 几乎不更新，所以推荐美团的 mpvue
- 而如果团队前端强大，自己做一套框架有没问题






# 10. 分析小程序的优劣势？
## 优势

- 容易上手，基础组件库比较全，基本上不需要考虑兼容问题
- 开发文档比较完善，开发社区比较全，支持插件式开发
- 良好的用户体验，无需加载，通过搜索和扫一扫就可以打开了，打开速度快，安卓上可以添加到桌面，与原生 APP 差不多
- 开发成本比 APP 要低
- 为用户提供良好的安全保障（小程序发布 严格的审查流程）

## 劣势

- 显示较多，页面大小不能超过 1M，不能打开超过5个层级的页面 
- 样式单一，部分组件已经是成型了的，样式不可以修改，例如：幻灯片丶导航
- 拓展面窄，不能分享朋友圈，只能通过分享到朋友，附近的小程序推广
- 依托于微信，微信开发后台管理系统
- 后台调试麻烦，因为 API 接口必须 https 请求且公网地址
- 真机测试，个别功能安卓和苹果表现迥异，例如安卓的定位功能加载很慢




# 11. 微信小程序 与 H5 的区别？
- **运行环境不同**（小程序在微信运行，H5 在浏览器运行）
- **开发成本不同**（H5 需要兼容不同的浏览器）
- **获取系统权限不同**（系统级权限可以和小程序无缝链接）
- **应用在生产环境的运行流畅度**（H5 需不断对项目优化来提高用户体验）

- **渲染线程与脚本线程**
  - 网页开发渲染线程和脚本线程是互斥，这也是为什么长时间的脚本运行可能回导致页面失去响应
  - 小程序中，二者是分开，分别运行在不同的线程中

- **有关 DOM 操作**
  - 网页开发者可以使用各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作
  - 小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的 DOM API 和 BOM API 
  - 这一区别导致了前端开发非常熟悉的一些库，例如 jQuery，Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJs 也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的




# 12. 小程序异步请求如何解决
**小程序为了提供用户体验，提供的api大部分都是异步操作，除了数据缓存里面有些同步操作**

```js
function getUserEntity() {
    wx.request({
        url: http_config.getUserDetail,
        data: {
            shaiOpenId: wx.getStorageSync("LoginSessionKey")
        },
        success: (res) => {
            let result = res.data;
            console.log(result);
            return result;
        },
        fail: () => {
            return "系统异常，请重试！"
        }
    })
}
module.exports.GetUserEntry = getUserEntity;

const com = require(`${root_path}/utils/common.js`)
let userEntity = com.GetUserEntity();
console.log(userEntity.Sex);
console.log("得到实体之后进行的操作");


//  改为
function GetUserEntity() {
    return new Promise(fucntion(resolve, reject) {
        wx.request({
            url: http_config.getUserDetail,
            data: {
                shaiOpenId: wx.getStorageSync("LoginSessionKey")
            },
            success: (res) => {
                let result = res.data;
                console.log(result);
                resolve(result);
            },
            fail: () => {
                reject("系统异常，请重试！");
            }
        })
    })
}
com.GetUserEntity().then((res) => {
    console.log(res);
}).catch((res) => {
    console.log(res);
})
```






# 14. 小程序关联微信公众号如何确定用户的唯一性
- 使用 `wx.getUserInfo` 方法 `withCredentials` 为`true`时可获取 `encryptedData`，里面有 `union_id`，后端需要进行对称解密。
- 如果开发者拥有多个移动应用丶网站应用和公众账号（包括小程序），可通过 unionid 来区分用户的唯一性，因为只要是同一个微信开发平台账户下的移动应用丶网站应用和公众账户（包括小程序），用户的 unionid 是唯一的。
- 换句话说，同一用户，对同一个微信开发平台下的不同应用，unionid 是相同的。






# 15. 小程序 和 Vue 生命周期
**问题？** 
- 你是否知道 `Page` 生命周期与组件的 `pagelifetimes` 生命周期执行顺序?
- 你是否知道 `behaviors` 中的生命周期与组件生命周期执行顺序？？？
- 异步组件（异步渲染的组件，通常是通过if条件判断是否渲染）的生命周期执行顺序是怎么样的，`pagelifetimes`会不会执行？??

## 小程序生命周期有哪些？

### App

- **onLuanch：**生命周期回调 -- 监听小程序初始化 
- **onShow：**生命周期回调 -- 监听小程序启动或切换前台
- **onHide：**生命周期回调 -- 监听小程序切后台

### Page 

- **onLoad：**生命周期回调 -- 监听页面加载
- **onShow：**生命周期回调 -- 监听页面显示
- **onReady：**生命周期回调 --  监听页面初始渲染完成
- **onHide：**生命周期回调 -- 监听页面隐藏
- **onUnload：**生命周期回调 -- 监听页面卸载

## onLoad 和 onShow 的区别？

- **onLoad**
  - 页面加载
  - 一个页面只会调用一次，之前加载的话就不跑了
  - 接受页面参数，可以获取 `wx.navigatoTo` 以及 `<navigator/> `中的 query
- **onShow**
  - 页面显示
  - 每次打开页面都会调用一次 

## onHide 和 onUnload 区别？

- **onHide：**页面隐藏，例如使用`wx.navigateTo`只是打开新页面，并不关闭原页面
- **onUnload:** 页面被卸载。例如使用 `wx.redirectTo` 重定向一个页面，原页面已经关闭

## 组件（Component） 的生命周期函数

- **created：**在组件实例刚刚被创建时执行
- **attached：**在组件实例进入页面节点树时执行
- **ready：**在组件视图层布局完成后执行
- **moved：**在组件实例被移动到节点树另一个位置时执行
- **detached：**在组件实例被从页面节点树移除时执行
- **error：**每当组件方法抛出错误时执行

## 组件所在页面的生命周期

- **show:** 组件所在的页面被展示时执行
- **hide：**组件所在的页面被隐藏时执行
- **resize：**组件所在的页面尺寸变化时执行

## 想一下加载一个页面（包含组件）的加载顺序?

- 首先执行 `App.onLaunch` -> `App.onShow`
- 其次执行 `Component.created` -> `Componnet.attched`
- 再执行`Page.onLoad` -> `Page.onShow`
- 最后执行 `Componnet.ready` -> `Page.onReady`

## 你是否知道`behaviors`中的生命周期与组件生命周期执行顺序？

- 同名字段的覆盖和组合规则中关于声明周期执行顺序，测试结果是想执行的父的behavior的生命周期，其次是behavior

<img src ="https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png"/>

可以看到，在页面`onLoad`之前会有页面 `created` 阶段，这其中就包含了组件的初始化，等组件初始化完成之后，才会执行页面的 `onLoad`，之后页面 `ready`事件也是在组件 `ready` 之后才触发的。





# 16. 小程序登录流程
<img src="https://xjnotxj-notes.oss-cn-shanghai.aliyuncs.com/default/2021-04-06-22-30-34.png">

**调用 `wx.login()` 获取临时登录凭证 `code`，并传回到开发者服务器。调用 `auth.code2Session` 接口，换取用户唯一标识 `openId` 会话秘钥`session_key`。之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。**

**注意：会话密钥 `session_key` 是对用户数据进行加密签名的密钥 。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。临时登录 `code` 只能使用一次。**
    

**微信小程序登录体系**

- 通过 `wx.login()` 获取到用户的code
- 通过`wx.request()`方法请求我们自己的后端，我们自己的服务器把 `appid`丶`appsecret`和`code` 一起发送到微信服务器。`appid` 和 `appsecret` 都是微信提供的，可以在管理员后台找到。
- 微信服务器返回了 `openid`
- 我们在自己的数据库中，查找了 `openid`，如果没有查到记录，说明改用户没有注册，如果有记录，则继续往下走
- 我们生成一个第三方 `session`，也就是 `session_id`，也就是用户唯一标识符。在 `redis` 中，把 `session_id ` 和用户的身份存进去。
- 返回 `3rd_session`
- 小程序把 `3rd_session`存到 `storage` 里面
- 下次请求时，先从 `storage` 里面读取，然后带给服务端
- 服务端从 `redis` 里面找到 `3rd_session`对应的记录，然后校验有效期






# 17. 小程序底层架构（小程序性能优化）
小程序的最终渲染体依然是浏览器内核，而不是原生客户端。

对于传统的网页来讲，UI 渲染和 JS 脚本是在一个线程中执行，所以经常会出现“阻塞”行为。微信小程序基于性能的考虑，启用了双线程模型：
- 视图层：也就是 webview 线程，负责启用不同的 webview 来渲染不同的小程序页面    
- 逻辑层：一个单独的线程执行 JS 代码，可以控制视图层的逻辑
<img src="https://img20.360buyimg.com/ling/jfs/t1/88668/37/14434/308258/5e650263Ebf67d978/06dee7fb8293b482.png" alt="双线程模型图">

然而，任何线程间的数据都是有延时的，这意味着逻辑层和视图层间通信是异步行为。除此之外，微信小程序提供了很多客户端原生能力，在调用客户端原生能力的过程中，微信主线程和小程序双线程之间也会发生通信，这也是一种异步行为。这种异步延时的特性会使运行环境复杂化，稍不注意，就会产生效率低下的编码。

所以会遇到以下问题
- 小程序启动慢
- 白屏时间长
- 页面渲染慢
- 运行内存不足

## 小程序启动阶段做的事情？

- 准备运行环境
在小程序启动前，微信会启动双线程环境，并在线程中完成小程序基础库的初始化和预执行。
> 小程序基础库包括 WebView 基础库和 AppService 基础库，前者注入到视图层，后者注入到逻辑层中，分别在所在层级提供其运行所需的基础框架能力。
- 下载小程序代码包

在小程序初次启动时，需要下载编译后的代码包到本地。如果启动了小程序分包，则只有主包的内容被下载。另外，代码包会保留在缓存中，后续启动会优先读取缓存。
- 加载小程序包

小程序代码包下载好之后，会被加载到适当的线程中执行，基础库会完成所有页面的注册。
> 在此阶段，主包内的所有页面 JS 文件及依赖文件都会被自动执行
> 在页面注册过程中，基础库会调用页面 JS 文件的Page构造器方法，来记录页面的基础信息（包括初初始数据丶方法等）
- 初始化小程序页面

在小程序代码包加载完成之后，基础库会根据启动路径找到首页，根据首页的基础信息初始化一个页面实例，并把信息传递给视图层，视图层会结合WXML结构丶WXSS样式和初始数据来渲染界面。

## 小程序启动太慢？

- 无用代码丶函数丶样式剔除
- 减少代码包中的静态资源文件
- 逻辑后移，精简业务逻辑
- 复用模板插件
- 分包加载
- 部分页面 H5 化

## 白屏时间过长？

- 启动本地缓存
- 数据预拉取
- 跳转时预拉取
- 分包预加载    
- 非关键渲染数据延迟请求
- 分屏渲染
- 接口聚合，请求合并
- 图片资源优化
  - 使用 WebP 格式
  - 图片裁剪&降质
  - 图片懒加载丶雪碧图优化
  - 降级加载大图资源
- 骨架屏

## 当调用`wx.navigateTo`打开一个新的小程序页面时，小程序会完成以下几步工作：

- 准备新的 webview 线程环境，包括基础库的初始化
- 从逻辑层到视图层的初始数据通信
- 视图层根据逻辑层的数据，结合 WXML 片断构建出节点树（包括节点属性丶属性绑定等信息），最终与 WXSS 结合完成页面渲染

由于微信会提前开始准备 webview 线程环境，所以小程序的渲染损耗主要在后两者，数据通信和节点树创建/更新的流程中。相对于的，比较有效的渲染性能优化方向就是：
- 降低线程间通信频次
- 减少线程间通信的数据量
- 减少 WXML 节点数量

## 如何提高渲染性能？

- 合并 setData 调用
- 只把与界面渲染相关的数据放在 data 中
- 应用层的数据 diff
- 去掉不必要的数据绑定
- 去掉不必要的节点属性
- 适当的组件颗粒度
- 事件总线，代替组件间数据绑定的通信方式
- 组件层面的 diff

## 内存占用过高？

- 内存预警
- 回收后台页面计时器
  - 在页面 onHide 的时候手动把定时器清理掉，有必要再在 onShow 阶段恢复定时器。
- 避免频发事件中的重度内存操作
  - onPageScroll 事件回调使用节流
  - 避免 CPU 密集型操作，譬如复杂的计算
  - 避免使用 setData，或减少 setData 的数据量
  - 尽量使用 `IntersectionObserver`来代替`SelectorQuery`，前者对性能影响更小
- 大图(占位图)丶长列表优化   






# 18. 使用 webview 直接加载要注意哪些事项？
- 必须要在小程序后台使用管理员添加业务域名
- h5 页面跳转至小程序的版本必须是 1.3.1 以上
- 微信分享值可以是小程序的主名称，如要自定义分享内容，需小程序版本在1.7.1以上
- h5 的支付不可以是微信公众号的 appid，必须是小程序的 appid，而且用户的 openid 也必须是用户和小程序的




# 19. 小程序调用后台接口遇到哪些问题？
- 数据的大小限制，超过范围会直接导致整个小程序崩溃，除非重启小程序
- 小程序不可以直接渲染文章内容这些类型的html文件，显示需借助插件

注：插件渲染会导致页面加载变慢，建议在后台对文章内容的 html 进行渲染，后台直接批量处理替换 p标签 和 div标签 为 view标签，然后其他的标签让插件来做做，减少前端的时间。






# 20. 微信小程序如何实现下来刷新？
- 现在 `app.json` 或 `page.json` 中配置 `enablePullDownRefresh: true`
- page里用 `onPullDownRefresh` 函数，再下拉刷新时执行
- 在下拉函数执行时候发起数据请求，请求返回后，调用 `wx.stopPullDownRefresh` 停止下拉刷新的状态





# 21. webview在的页面怎么跳转回小程序
- 先在管理后台配置域名和白名单
- 要引入相关的js
`<script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.3.2.js"></script>`
```js
wx.miniProgram.navigateTo({
    url: 'pages/login.login$id=' + id
})

// 跳转到小程序导航页面
// 小程序导航的页面可以通过switchTab，但默认情况是不会重新加载数据的。如需加载新数据，则在success属性中加以下代码
wx.miniProgram.swtichTab({
    url: '/pages/index/index',
    success: function(e) {
        var page = getCurrentPage().pop();
        if(page === undefined || page === null) {
            return;
        }
        page.onLoad();
    }    
})
```





# 22. bindtap 和 catchtap 的区别？
- bind 事件绑定不会阻止冒泡事件向上冒泡
- catch 事件绑定可以阻止冒泡事件向上冒泡






# 23. `wx.navigateTo`丶`wx.redirectTo`丶`wx.reLaunch`丶`wx.switchTab`丶`wx.navigateBakc`区别
- **wx.navigateTo:** 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以发挥到原页面。小程序页面栈最多十层。在小程序插件使用时，只能在当前插件的页面中调用。
- **wx.redirectTo:** 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。在小程序插件中使用时，只能在当前插件的页面中调用。
- **wx.reLaunch：**关闭当前所有页面，打开到应用内的某个页面。在小程序插件中使用时，只能在当前插件的页面中调用
- **wx.switchTab:**  跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。在小程序插件中使用，只能在当前插件的页面中调用。
- **wx.navigateBack:** 关闭当前页面，返回上一个页面或多级页面。可通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。在小程序插件中使用时，只能在当前插件的页面中调用。






# 24. 小程序 和 Vue 双向数据绑定不同？
小程序直接 this.data 的属性是不可以同步到视图的，必须调用 this.setData();






# 25. 小程序 和 Vue 写法的不同
- **循环遍历：** 小程序是`wx:for="list"`, Vue是`v-for="list"`
- **调用data模型：**小程序是this.data.unifo,Vue是this.unifo
- **给模型赋值：**小程序是this.setData({unifo: 1}), Vue是直接this.unifo = 1






# 26. 提高小程序的应用速度
- 提高页面加载速度
- 用户行为预测
- 减少默认data的大小
- 组件化方案





# 27. 打开另一个小程序
小程序互相跳转需要两个小程序关联到同一个公众号上
```js
if(wx.navigateToMiniProgram) {
    wx.navigateToMiniProgram({
        appId: '',
        path: "pages/index/index?id=123",
        extraData: {
            foo: "bar"
        },
        envVersion: "develop",
        success: function() {
            
        }
    })
}
```





# 28. 微信小程序 与 Vue 区别

- **生命周期不一样**，微信小程序生命周期比较简单
- **数据绑定也不同**，微信小程序数据绑定需要使用`{{}}`,Vue直接就可以了
- **显示与隐藏元素**，Vue中使用 `v-if` 和 `v-show`，在小程序中使用 vx-if 和 hidden 控制元素的显示与隐藏
- **事件处理不同**，小程序中，使用 bind:event 或者 catch:event 绑定事件，Vue 中使用 v-on:event 绑定事件，或者使用 @event 绑定事件
- **数据双向绑定也不一样**，Vue 中只需要在表单元素上加上 `v-model`，然后再绑定`data`对应的一个值，在表单元素内容发生变化的时候，data中对应的值也会相应的改变，这是Vue非常nice的一点。微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个data中的声明的变量。






# 29. 小程序对 wx:if 和 hidden 使用的理解？
- `wx:if `是遇 `true` 显示, `hidden `是遇 `false` 显示
- `wx:if `在隐藏的时候不渲染，而 `hidden` 在隐藏时仍然渲染，只是不显示
- 所以如果频繁渲染的话，用 `wx:if` 将会消耗更多资源，因为每次呈现的时候它都会渲染，每次隐藏的时候，它都会销毁。
- 如果切换不频繁的话，用 `wx:if` 相对来说较好些，因为它会避免初始就一下渲染那么多






# 30. 小程序 `onPageScroll` 方法的使用注意什么？
由于此方法调用频繁，不需要时，可以去掉，不要保留空方法，并且使用 `onPageScroll` 时，尽量避免使用 `setData()` ,尽量减少 `setData` 的使用频次。






# 31. 小程序同步 API 和异步 API 使用注意事项？
- `wx.setStorageSync`是以 Sync 结尾的 API 为同步 API，使用时使用 `try-catch` 来查看异常，

- 如果判定API为异步，可以在其回调方法`success`丶`fail`丶`complete`中进行下一步操作。






# 32. 微信小程序埋点





# 33. 微信小程序工程化

规范化丶组件化丶工具化丶自动化测试丶持续集成系统

## 规范化

- 用户体验规范化
- 组件规范化
- 埋点上报规范丶数据接口规范丶日志规范
- huasky
- lint-staged
- CommitLint 
- ESLint
- Prettier
- Git 分支规范化
- 目录结构规范化

## 规模暴涨带来的问题

- 开发
  - 开发调试越来越卡
  - 大量相同丶相似代码块，造成冗余
- 测试
  - 测试容易遗漏
  - 版本质量无法保证
- 打包
  - 代码包超限
  - 多小程序间代码无法复用
- 发布
  - 发布流程过于繁琐，效率低下     

## 开发阶段调试卡顿？

解决方案：单页面抽取，通过工具化的手段进行文件依赖分析，仅提取当前开发页面所需的文件

## 大量相同丶相似代码块，造成冗余？

### 相同丶相似代码的形成

- 复制粘粘，相似功能拷贝丶跨小程序拷贝
- 对项目不熟悉，重复造轮子

### 解决方案 - 项目治理

- 组件化，通过人工手段进行分析，提取NPM包，推动业务侧改造，减少重复代码
- 代码审计，通过工具化手段进行分析，给出建议，避免重复代码生成

### 组件化（NPM）如何做？

- 分析公共文件，提取成NPM包
- 分析常见业务代码，提取成NPM包
- 对 NPM 包 API 重新设计丶评审
- JsDoc 同步生成 API 文档

### 组件化的质量及管理？

- Jest - 完善的测试用例
- Istanbul - 高标准的覆盖率
-  TspeScript
-  Lerna - Monorepo的方式管理所有基础库
-  多端复用 - 不同环境加载不同文件（cookie.(h5 | node | wxapp).js）

### 低版本NPM兼容性问题？

- 微信小程序从基础库2.2.1开始支持NPM，我们小程序仍有12.8%的用户低于此版本
- 在打包阶段，将所有源码中用 CLI 对 NPM 包的引用修改为相对路径

重复代码很多，那重复检测的依据是什么，常见的有基于 token 的对比和基于 AST 的对比
就token的重复检测原理是江湖代码转换token，然后再判断一定长度token 的md5是否相同

### 测试工作量飙升和质量无法保证？

- 使用小程序自动化测试工具 - Sandbox
- 通过自动化测试沙盒，解放了大量测试人力，使得他们可以更加专注于版本特性，保证了版本质量。

### 代码包超限的问题？

- 影响发版进度
- 新增业务特性受限
- 启动过慢，影响性能甚至导致崩溃
解决方案 减少体积的方式
- 找出已下线页面（PV为0），删掉
- H5化，小程序页面使用H5页面替换
- 本地图片转CDN
- 分包，减少主包体积（总包体积不变）
- 接口聚合，将部分逻辑移到后端
- 找出未有用的文件丶函数，删掉

目前在梳理前端应用时发现很多代码不规范的地方，包括简单的js问题以及代码格式化的问题，造成了代码可读性下降，另外各种历史代码也是“风格迥异”，甚至影响了应用质量。

**针对的痛点如下：**
- **代码规范落地难：** 代码规约相当于团队乃至公司的整个技术团队的契约，同时这些规范是经过许许多多前辈大师经过项目的洗礼留下的宝贵财富可以在开发中少走许多的弯路，但是面对开发规范经常面临的现状是很难落地，总是“拆东墙补西墙”，归根结底在于需要工具去强行保证代码必须经过代码开发规范的扫描。
- **低质量代码带入线上应用：** 在实际开发现状中开发人员可以很简单的执行`git push`操作将本地代码带入远程分支上，如果代码质量低下就很容易对线上应用质量埋下隐患，至于在合并的时候进行 CR，至于反馈链路太长，最好的时候本地进行 commit 的时候，最起码保证当前代码能够满足团队制定的开发规范，如果不通过，commit 都无保证法成功，这样能够从源头保证代码质量
- **代码格式难统一：** 按照现状团队的开发成员对代码的格式都有很大的不同，甚至有些人字符串喜欢双引号，有的人喜欢用单引号等等问题，如果代码格式化问题不统一，总觉得互相查看其它人的代码总觉得怪怪的，甚至代码格式错乱，甚至影响代码可读性，无疑也增加了团队内的沟通成本，针对这样的情况，需要一种工具能够保证团队内代码的格式是一致的。 
- **低代码质量文化难落地：** 通过引入代码质量工具，在开发过程中能够时刻对自身代码质量进行约束，逐渐培养自身对代码质量有“洁癖”的开发观念，同时也会成为团队至自身对质量化落地的一个抓手。


- ESLint: 是在ECMAScript/JavaScript代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。相较于Prettier更为自由，并且更为严格，也可以分享JS当中的错误。
- Prettier: 能够解析代码，使用你自己设定的规则来重新打印出格式规范的代码。正因为Prettier Opinionated的特性，所以我们不需要配置过多的规则，并且它能够支持更多编辑器的插件以及对于html丶css等文件的格式化
- **huasky + lint-staged：** 
  - hasky让Git钩子变得容易，让git钩子的功能加到pakage的script里面，是的我们有能力直接调用其他命令而不用吧钩子脚本写在项目的.git/hool里面，方便团队间Git钩子命令的共享，
  - lint-staged检查所有被git add加入的文件，对这些文件执行你需要的命令。让;
  - 由于每次提交代码之前，对整个项目进行eslint处理耗时长且容易对老项目产生致命的Bug。为了解决这个问题，我们引入hasky+lint-staged可以只对我们本次commit修改的代码进行eslint处理，让Linting更有意义。这样，您可以确保没有错误进入存储库并强制执行代码样式。
- **Commitizen**
- CommitLint 









# 34. 微信小程序长列表优化（亮点）

**有些需求需要展示长列表，无限下拉都会一直显示出更多的数据，但是当一个页面展示的 DOM 节点过多的时候，会造成小程序页面的卡顿严重的会直接白屏。**

## 原因：

- 列表数据过大，不断获取下一屏的数据，`setData` 的数据越来越多的时候耗时高
- 渲染 DOM 结构多，每次 `steData` 都需要创建新的虚拟树，和旧的树 `diff` 操作耗时都比较高
- DOM 结构多，占用的内存高，造成页面被系统回收的概率变大，会白屏

## 不需要一次性拉取所有的数据

- 一屏你拉取所有的节点，用户根本看不完，所以意义不大
- 数据太大，造成网络传输慢
- setData 也慢，造成首屏慢

## 实现方案：通过分屏无限下拉长列表

- 将渲染列表数组 list 改成 二维数组
- 只渲染可视区域的那一屏以及它前后一屏的元素。其它用空位占位做到第二步，我们还需要完成三小步
  - 需要知道每一屏的高度，这样我们才能给这个占位的空白 div 元素设置高度
  - 渲染下一屏的 last 的数据，除了保留 last，以及 last-1 那一屏的渲染，其它节点应该为空
  - 如果是获取非最后一屏幕的，通过监听 onscrollTop 获取到 scrollTop 的值，算取当前应该渲染那一屏，再重新组装数据 setData

## 为什么改成二维数组？

- 因为我们是以一屏的数据为单位，所以用二维数组来装每一屏的数据，方便以屏为渲染单位渲染元素
- 性能优化
  - 原来我们是不停的获取新一屏的数据就不断的 concat 进来，再去 setData
  - 这样的话，到后期这个 finalArr 会越来越大，由于 setData 的调用会把数据从逻辑层传到渲染层，数据太大会增加通信时间。在性能不好的机型上，setData 就会占用很长的时间，从而造成页面卡顿
  - 而我们通过改成二维数组，二维数组里的每个子数组都用来装一屏的数据，然后每次只 setData 当前的下屏幕的数据，就可以减少这个通信时间。





# 35. 小程序自动化测试从入门到实践

## 背景

随着小程序项目越来越复杂，业务场景越来越多，花费在回归测试上的时间越来越多，前端自动化测试就非常有必要提上日程。

今天要带来的是：小程序自动化测试入门教程。

## 什么是小程序自动化

使用小程序自动化 SDK miniprogram-automator，可以在帮助我们在小程序中完成一些事情，比如：控制小程序跳转到指定页面，获取小程序页面数据，获取小程序页面元素等。

配合 jest 就可以实现小程序端自动化测试了。话不多说，我们开始吧。

## 准备

- 项目根目录 mini-auto-test-demo 里面准备两个目录 miniprogram 放小程序代码 和 test-e2e 放测试用例代码

  ```js
   |— mini-auto-test-demo/  // 根目录
      |— miniprogram/       // 小程序代码
         |— pages/    
             |— index/      // 测试文件
      |— test-e2e/          // 测试用例代码
      |— index.spec.js    // 启动文件
      |— package.json
  ```

  index 文件夹下准备用于测试的页面

  ```js
  <!--index.wxml-->
    <view class="userinfo">
        <view class="userinfo-avatar" bindtap="bindViewTap">
          <open-data type="userAvatarUrl"></open-data>
        </view>
        <open-data type="userNickName"></open-data>
    </view>
    
    /**index.wxss**/
  .userinfo {
    margin-top: 50px;
    display: flex;
    flex-direction: column;
    align-items: center;
    color: #aaa;
  }
  .userinfo-avatar {
    overflow: hidden;
    width: 128rpx;
    height: 128rpx;
    margin: 20rpx;
    border-radius: 50%;
  }
   
  // index.js
  // 获取应用实例
  const app = getApp()
  Page({
    data: {
      userInfo: {},
    },
    // 事件处理函数
    bindViewTap() {
      wx.navigateTo({
        url: '../logs/logs'
      })
    }
  })
  ```

- 微信开发者工具 -> 设置 -> 安全设置 -> 打开服务端口

  <img src="https://pic4.zhimg.com/80/v2-d5fb51bc63603e99cc95a299e5b318cb_720w.jpg">

- 安装 npm 包，如果根目录没有 package.json 文件，先执行

  ```js
  npm init
  ```

  如果根目录已经有 package.json 文件，执行以下命令：

  ```js
  npm install miniprogram-automator jest --save-dev
  npm i jest -g 
  ```

  安装需要的依赖

- 在根目录下新建 index.spec.js 文件

  ```js
  const automator = require("minioprogram-automator");
  
  automator.launch({
      cliPath: "/Applications/wechatwebdevtools.app/Contents/MacOS.cli", // 工具 cli 位置
      projectPath: "/Users/SONG/Documents/github/mini-auto-test-demo/miniprogram" // 项目文件地址
  }).then(async miniProgram => {
      const page = await miniProgram.reLaunch('/pages/index/index');
      await page.waitFor(500);
      const element = await page.$(".useinfo-avatar");
      console.log(await element.attribute("class"));
      await element.tap();
      await miniProgram.close();
  })
  ```
  
  ### 这里要注意修改为自己的 cli 位置和项目文件地址：
  
  - cliPath
  
    可以在应用程序中找到微信开发者工具，点击右键点击“点击包内容”
  
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/200f2e95920f45698a9c6b11f1efe24e~tplv-k3u1fbpfcp-watermark.image">
  
    找到 cli 后，快捷键：command+option+c 复制路径，就拿到了
  
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57dc60820aae43f2932437f584deb4e9~tplv-k3u1fbpfcp-watermark.image">

 - projectPath

   注意！！项目路径填写的是小程序文件夹 miniprogram 而不是 mini-auto-test-demo

## 启动

写好路径后，在 mac 终端进入 mini-auto-test-demo 根目录 或 vscode 终端根目录执行命令：

```js
node index.spec.js
```

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a67bc2ecd0b4f7db4b08dca8e3c9ae0~tplv-k3u1fbpfcp-watermark.image">

你会发现微信开发者工具被自动打开，并执行了点击事件进入了 log 页面，终端输出了 class 的值。到此你已经感受到了 自动化。

## 自动化测试

在一开始准备的 test-e2e 文件夹下新建 integration.test.js 文件

引入 miniprogram-automator，链接自动化操作端口，把刚刚 index.spec.js 中的测试代码，放到 jest it 里，jest 相关内容我们这里就不赘述了，大家可以自行学习。

```js
const automator = require("miniprogram-automator");

describe("index", () => {
    let miniProgram;
    let page;
    const wsEndpoint = "ws://127.0.0.1:9420";
    beforeAll(async() => {
        miniProgram = await automator.connect({
            wsEndpoint: wsEndpoint
        })
    }, 30000)
    
    if("test index", async() => {
        page = await miniProgram.reLaunch("/pages/index/index");
        await page.waitFor(500);
        const element = await page.$(".useinfo-avatar");
        console.log(await element.attribute("class"));
        await element.tap();
    })
})
```

在 package.json scripts 添加命令

```js
"e2e": "jest ./test-e2e integration.test.js --runInBand"
```

测试代码写好了，接下俩如何运行呢？这里我们提供另外一个方法。

## cli 命令行调用

你一定会问，刚刚我们不是学习了启动运行，这里还要学习另外一种方法，大家都知道，一般团队都是多人合作的，大家的项目路径都不一样，难道每次改 projectPath吗？太麻烦了，使用 cli 就不需要考虑在哪里启动，项目地址在哪里。

打开终端进入微信开发者工具 cli 文件夹（路径仅供参考）：

```js
cd /Applications/wechatwebdevtools.app/Content/MacOS
```

执行命令（如果你的微信开发者工具开着项目，先关掉）

```js
./cli --auto /User/SONG/Documents/github/mini-auto-test-demo/miniprogram --auto-port 9420
```

微信开发者工具通过命令行启动

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e76f9a5b5ef476ea84cf142c1ddc079~tplv-k3u1fbpfcp-watermark.image">

启动后在项目根目录下执行，可以看到测试通过

```js
npm run e2e
```

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72cea710f66f4553a649ecaa206b3a7e~tplv-k3u1fbpfcp-watermark.image">



至此，我们已经可以写测试用例了。

## 下载 小程序自动化 SDK miniprogram-automator

**Automator** 模块提供了启动及连接开发者工具的方法

**MiniProgram** 模块提供了控制小程序的方法

**Page** 模块提供了控制小程序页面的方法

**Element** 模块提供了控制小程序页面元素的方法





# 36. 微信小程序的 localStorage 多大

10 M左右







# 37. 小程序前端监控

## 前言

你是否碰到业务反馈，线上的小程序某个页面打不开，订单没法结算了，但是你当时测试的时候都是好好的。

由于线上环境复杂，一些问题只会在特定网络环境下或者设备上发生，对于这类问题，异常信息的手机就显得格外重要了，我们不但希望手机错误的堆栈信息，还需要用户操作流程，设备等，以便复现错误。

简单收集

小程序App() 生命周期提供了 onError 函数，可以通过在 onError 里收集异常信息

```js
App({
    // 监听错误
    onError: function(err) {
       // 上报错误
        wx.request({
            url: "https://url", // 自行定义报告服务器
            method: "Post",
            errMsg: err
        })
    }
})
```

## 用户操作路径收集

一些比较隐蔽的错误如果只有错误栈信息，排查起来会比较难，如果有用户操作的路径，在排查时就方便多了。

方法一：暴力打点方法收集

优点：简单直接

缺点：污染业务代码，造成较多垃圾代码

方法二：函数劫持（推荐使用）

需要在 APP 函数中的 onLaunch丶onShow丶onHide 生命周期插入监控代码，我们通过重写 App 生命周期函数来实现。

```js
App = function(app) {
    ["onLaunch", "onShow", "onHide"].forEach(methodName => {
        app[methodName] = function(options) {
            // 构造访问日志
            var breadcrumb = {
                type: "function",
                time: util.now(),
                belong: "App", // 来源
                method: methodName,
                path: options && options.path, // 页面路径
                query: options && options.query, // 页面参数
                scene: options && options.scene // 场景编号
            }
            self.pushToBreadcrumb(breadcrumb) // 把执行对象加入面包屑中
        }
    })
}
```

但是这样写，会把用户定义的内容给覆盖掉，所以我们还需要把用户定义的函数和监控代码合并。

```js
var originApp = App;
App = function (app) {
    // ... 此处省略监控diamond 
    // ... 此处省略监控diamond
    originApp(app); // 执行用户定义的方法
}
```

记录结果

可以从下面的 json 看出，用户到了 detail 页面，执行了 onLoad => getDetail => onReady => buy 当执行 buy 方法的时候报错

````js
[
    {"method":"onLoad","route":"pages/film/detail","options":{"id":"4206"}},
	{"method":"getDetail","route":"pages/film/detail","options":{"id":"4206"}},
	{"method":"onReady","route":"pages/film/detail","options":{"id":"4206"}},
	{"method":"buy","route":"pages/film/detail","options":{"id":"4206"}}
]
````

上报策略

考虑到大型应用中，日志量比较大，我们采取抽样，合并，过滤三个方法减少日志的输出，代码实现可以参考 lib/report.js

## 原理

之前也做过浏览器 web 端的 SDK 数据埋点上报，其实原理大同小异：通过劫持原生方法，获取需要上报的数据，最后再执行原始方法，这样就实现无痕埋点。

举个例子：我们监控所有 web 页面的 ajax 请求，每次发送 ajax，都需要在控制台打印出发送的 url

平时我们开发，发送 ajax 一般用的都是封装好的库，例如 jQuery丶Axios 等，然而这些库，底层仍然用的是浏览器原生的 XMLHttpRequest 对象，因此我们只需要修改 XMLHttpRequest 对象即可。

注意：由于 JS 的灵活性，修改原生方法是一件很容易的事，然而并不鼓励这样做！

```js
// 把这段代码放在所有 JS 代码之前，我们就实现了拦截 ajax 的需求
window.XMLHttpRequest.prototype = (function(originOpen) {
    return function(method, url, async) {
        console.log("发送了ajax，url是：", url);
        return originOpen.apply(this, arguments);
    }
})(window.XMLHttpRequest.prototype.open);
```

在这个立即执行函数中，我们把原生的 open 方法通过 originOpen 暂时存储起来，然后在外面包裹一层函数，实现了打印输出 url  的功能，最后通过 origin.apply 让原生方法运行，这样就实现了无痕拦截。

监控小程序

小程序的运行环境没有 window 和 document 对象，它只暴露了一个 wx 全局对象，发送网络请求则是通过 wx.request 这个 api，因此这次我们需要拦截的就是 wx.request 方法

我们试着更改一下 wx.request

```js
wx.request = function() {
    console.log("666666");
}
```

这时控制台会报错 TypeError: Cannot set property request of #<Object> which has only a getter

这是因为 wx.request 这个属性，只有 get 方法没有 set 方法，我们可以通过 Object.getOwnPropertyDescriptor 验证：

```js
const des = Object.getOwnPropertyDescriptor(wx, "request");

// des {
//     configurable: true,
//     enumerable: true,
//     get: f(),
//     set: undefined    
// }
```

我们可以换种方式修改：

```js
const originRequest = wx.request;
Object.defineProperty(wx, "request", {
    configurable: true,
    enumerable: true,
    value: function() {
        const config = arguments[0] || {};
        const url = config.url;
        console.log("发送的ajax，url是：" + url);
        return originRequest.apply(this, arguments);
    }
})
```

这次就实现拦截功能了！

## 监控异常

小程序的注册函数 App 有个全局的 onError 方法，我们可以在小程序的入口文件 app.js 先注册一下该方法：

```js
App({
    onError: function(err) {
        console.log("上报错误啦！");
        wx.request({
            url: "http://monior.com.monitor.error",
            data: err
        })
    }	
})

App({
    // 其它逻辑
})
```

不过需要注意的是：如果后续的程序重写了 onError 的话，将会导致之前注册的 onError 失效

解决方法可以是：我们监控 SDK 可以暴露一个接口，让接入方自己在 onError 中调用我们的接口

```j
App({
	onError: function (err) {
		monitor.notifyError(err)
	}
})
```

## 上报数据

收集好需要的数据，当然就要上报后台。怎么上报？当然还是用的 wx.request 发送请求

这里就容易出现一个死循环：如果用之前被我们包装过的 wx.request 上报数据，那么上报数据这个 ajax 请求，也会被我们认为是普通的 ajax 请求，然后又会触发上报，这样来来回回，无穷无尽的发送上报。

解决方案有多种，比如：

### 方案1

可以在包装 wx.request 的时候，判断发送的 url 如果是上报接口，那么就不再上报了。

```js
const originRequest = wx.request;
Object.defineProperty(wx, "request", {
    configurable: true,
    enumerable: true,
    writable: true,
    value: function() {
        const config = arguments[0] || {};
        const url = config.url;
        if(url.indexOf("http.//monitor.com") > -1) {
            // 直接发送请求，不上报
            return originRequest.apply(this, arguments);
        }
        
        console.log("上报数据了");
        wx.request({
            url: "http://monitor.com/monitor/ajax",
            data: config.data
        })
        
        return originRequest.apply(this, arguments);
    }
})
```

方案二

在包装 wx.request 之前，保留一份最原始的 wx.request 方法，所有的上报请求，就不走被包装过的方法，而走最原始的方法

```js
const myRequest = wx.request;

const wrapRequest = function() {
    const originRequest = wx.request;
    Object.defineProperty(wx, "request", {
        configurable: true,
        enumerable: true,
        writable: true,
        value: function() {
            const config = arguments[0] || {}';
            const url = config.url;
            
            console.log("上报数据了");
            // 使用最原始的 request 方法
            myRequest({
                url: "http://monitor.com/monitor/ajax",
                data: config.data
            })
            
            return originRequest.apply(this, arguments);
        }
    })
}

wrapRequest();
```

## 其它事件

实际开发中当然还有更多的细节，比如监控项目的鉴权，SDK的代码结果，上报前的收集和聚合等等，本文就不详细展开了。







# 38. 如何控制小程序的页面的分享？如某些敏感页面。

wx.updateShareMenu()







# 39. 在微信小程序里实现图片预加载组件

## 网页中的图片预加载

我们知道在 Web 页面中实现图片的预加载其实很简单，通常的做法是在 JS 中使用 Image 对象即可，代码大致如下：

```js
var image = new Image();
image.onload = function() {
    console.log("图片加载完成")
}
img.src = "http://misc.360buyimg.com/lib/img/e/logo-201305.png";
```

然而在微信小程序（以下简称小程序）里面实现图片的预加载要更麻烦一些，因为小程序里并没有提供类似 Image 这样的 JS 对象。

## 小程序必知必会

- 小程序框架的核心是一个响应式的数据绑定系统，整个系统分为视图层和逻辑层两块，视图层即页面模板（后缀为 .wxml 的文件），逻辑层即页面 JS 文件
- 小程序的页面模板由一系列的基础组件组合而成，如 view丶text丶buttion 等
- 页面内容的更新基于数据的单向绑定来进行，通过 JS 调用 Page 对象的 setData 方法来更新模板中绑定的数据
- 视图层到逻辑层的通信是通过事件完成的，在组件中声明事件的回调，JS 端可监听到界面交互的发生丶组件状态的变化等
- 在 WXML 文件中，可通过 template 进行模板的复用，若 template 是在不同文件里定义的，需要先通过 import 语句进行引入

这里有个官方的简单例子可以用来帮助理解：

```js
Hello {{name}}!
Click me!
```

```js
// 脚本文件 foo.js
Page({
	data: {
       name: "WeChat"
    },
    changeName: function(e) {
        this.setData({
            name: "MINA"
        })
    }
})
```

运行这个界面会看到一行 Hello Wechat！的文字及有个按钮，点击按钮后文字会变成 Hello MINA!

## 在小程序中加载图片

小程序提供了一个 image 组件（类似 HTML 中的 img 标签），并且可以设置 src 及加载成功或失败的回调，使用起来很简单

<img src="http://misc.360buyimg.com/lib/img/e/logo-201305.png">

```
// 脚本文件
Page({
	imageOnLoad(ev) {
		  console.log(`图片加载成功，width: ${ev.detail.width}; height: ${ev.detail.height}`)
	},
	imageOnLoadError() {
		console.log("图片加载失败");
	}
})
```

运行以上代码，顺利的话页面会显示出一张图片，同时控制台会打印出图片宽高的日志信息

## 将功能抽离出公用组件

接下来我们考虑实现这么一个功能，在页面上载入一张尺寸和 K 数都很大的图片，由于图片很大，下载需要一定的时间，而在这段时间内，用户看到的是空白或是不完整的图片，体验显然不好。

一种常用的优化手段是先加载一张缩略图，该缩略图 通过样式设置为和原图一样的宽高，这样用户首先能很快地看到一张模糊的图片，此时再去对原图做预加载，加载完成之后对缩略图进行替换，因为此时图片已经下载过了，所以界面能无缝地切换为原图显示，效果如下：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/1/14/34d03863147a54f191d06a41451b1447~tplv-t2oaga2asx-watermark.awebp">

完成这个优化操作的关键就在于需要一个公共的图片预加载组件的支持，接下来我们分解步骤来看看如何实现：

- 新建 demo 页面及组件相关的文件 img-loader.js 和 img-loader.wxml，组件需要和页面一样有个模板文件，是因为小程序无法动态地插入模板结构。然后在 demo.wxml 里通过 import 语句引用模板组件，在 demo.js 里通过 require 语句将组件脚本进行引入
- 在页面中通过 template 调用组件模板并传入数据，这里我们传递一个名为 imgLoadList 的图片数组过去
- 在页面脚本中的 onLoad 方法中对组件进行初始化，并将 this 对象传入，因为组件内必须通过 Page 对象的 setData 来更新模板里的内容
- 在组件的 img-loader.js 中定义一个 load 方法用来创建一个图片的加载，将传入的 src 添加到加载队列中，并使用 setData 方法更新队列数据
- 接下来在组件 img-loader.wxml 中通过接收到的图片队列数据，用 wx:for 指令去生成 image 组件对图片进行加载，同时将成功及失败的回调绑定到 img-loader.js 中的方法中，最终再回调回 Page 对象中。

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/1/14/a3325d876889ae320459f7f7b19f5faa~tplv-t2oaga2asx-watermark.awebp">

可以看出，由于小程序无法动态地插入模板结构，所以相对于普通网页端的组件调用，这里多出了在 WXML 文件中引入及使用模板这个步骤，而其它部分对于调用方（即 Demo 页面）来说则是相似的，下面是完整的 Demo 页面的代码。

```js
Click To Load Image
{{ msg}}
```

```js
// demo.js
// 引入图片预加载组件
const ImgLoader = require("../../img-load/img-loader.js");
// 缩略图 80x50 3KB
const imgUrlThumbnail = "http://storage.360buyimg.com/mtd/home/lion1483683731203.jpg";
// 原图 3200x2000 1.6MB
const imgUrlOriginal = "http://storage.360buyimg.com/mtd/home/lion1483624894660.jpg";
Page({
    data: {
        msg: "",
        imgUrl: ""
    },
    onLoad() {
        // 初始化图片预加载组件
        this.imageLoader = new ImgLoader(this);
    },
    loadImage() {
        // 加载缩略图
        this.setData({
            msg: "大图正拼命加载...",
            imgUrl: imgUrlThumbnail
        })
        // 同时对原图进行预加载，加载成功后再替换
        this.imgLoader.load(imgUrlOriginal, (err, data) {
        	console.log("图片加载完成", err, data.src);
        	this.setData({msg: "大图加载完成~"});
        	if(!err) {
                this.setData({ imgUrl: data.src });
            }
        })
    }
})
```

如果把图片加载完成的回调统一指定成 Page 对象中的方法，则可以很方便地处理多张图片的加载，这里也写了个例子，效果如下：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/1/14/d70f15d1ee1b07353d8b352e4d25526b~tplv-t2oaga2asx-watermark.awebp">







# 40. 给小程序再减重 30% 的秘密 - 京喜小程序首页 瘦身实战

##  前言

在 Web 开发场景，减少代码体积虽然是性能优化的一个方向，还没到锱铢必较的程度。但是在小程序场景，由于代码包上传阶段限制了主包 2M 和总包 16M（近期微信官方正在内测将总包上限调整至 20M）的尺寸，超过就会面临无法发版的风险，代码包体积的优化就变得特别重要了。京喜小程序首页作为微信购物的大入口，承载大量流量，功能模块众多，又要与其它核心业务和公共组件共享 2M 的主包空间，因此代码包瘦身的工作不断进行，否则无法满足业务的快速增长。本文将结合以往优化策略与最近一次瘦身实战，分享小程序代码瘦身的经验与思考。

## 常见的瘦身方法

京喜首页项目是一个优化良好的项目，对于常见的优化措施，已经有过很好的实践，就让我们先回顾一下有哪些常见的优化策略：

- 代码分包：将相对独立的页面和组件拆分到分包，可以解决主包体积受限的问题
- 依赖分析：移除未引用的页面丶组件和其它文件
- 避免使用本地资源：除了兜底图片，其它都尽可能使用 url 的方式，由于 base64 图本质上是将信息编码成长字符串，也会占用很多空间，不建议使用
- 对所有类型的文件都进行压缩并清理注释，包括：JS丶WXML丶WXSS 和 JSON

此外，京喜首页团队还针对 Taro 开发场景进行了如下优化

- 分析出编译后每个文件的高频重复代码（如处理兼容性的 pollyfill 代码），拆分生成公共文件替换原引用以实现共用。

## 标准和工具

在正式开始介绍瘦身实践之前，我们先来看下代码包体积的衡量标准和统计方式

小程序上传代码以代码尺寸为准，所谓 2  M的限制，就是指该尺寸不能超过 2048 KB

从信息传输角度来看，Gzip 等压缩工具可以进行很多信息化编码优化，因此一些内容重复是可以容忍的，但是由于我们的目标是为了解决小程序上传限制，就只有对代码尺寸锱铢必较了。

在开发者工具-详情-基本信息-上传预览或上次上传，可以查看到最近一次的代码包体积，本文接下来介绍的优化都是以缩小这个体积为目的

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/401551d2a2734259bce109b21c7a81e0~tplv-k3u1fbpfcp-watermark.awebp">

但是代码上传生成模板速度很慢，如果每次都要根据这里的数据来统计代码变化，效率太低了

在未改动项目配置的情况下，我们就可以间接以代码目录的文件体积大小作为变化参考。怎么方便的统计文件体积呢？这里我用了 tree-cli，利用它提供的参数，可以输出具备尺寸统计和排序功能的代码文件清单：

```js
npm install -g tree-cli

// 目标文件
cd target-diretory

// 删除文件为 size-analysis.md
tree -s --sort=size -o size-analysis.md
```

清单内容格式如下：

```js
.
├── [      1000]  index.js
├── [       500]  index.wxss
├── [       500]  index.wxml
├── [       500]  index.json
├── [      4000]  components
│   ├── [      4000]  child
│   │   ├── [      1000]  index.js
│   │   ├── [      1000]  index.wxml
│   │   ├── [      1000]  index.wxss
└── └── └── [      1000]  index.json
  
6500 bytes used in 2 directories, 8 files
```

## 瘦身实践

### 字体和颜色的全局共用

小程序文档内关于继承样式的说明为：继承样式，如 font，color，会从组件外继承到组件内

分析项目现状，我们通常会把字体定义放在公共 CSS 文件内，随着页面或组件引入公共 CSS丶font 也将被重复引入，可以通过改造，把 font 的定义仅放在 app.wxss 内，取消组件和页面的引入，可以达到减少整体代码包体积的目的。

关于这一项首页项目体积减少 1%，预计整个项目还有 20kb 左右的 font 定义可清理

如果有全局的颜色定义，也可以进行类似的优化

### 样式补全功能的使用

**作为 Web 开发者，对 -webkit- 这种前缀一定不陌生，为了适配不同浏览器内核，通常我们会在编译阶段使用 autoprefixer 进行样式的自动补全。**

而小程序开发者工具也提供了样式补全的能力：详情 - 本地设置 - 可以勾选【上传代码时样式自动补全】

这个补全和我们在编译时的有什么不同呢？

关键在于它实现的时机：如果是本地模板上传前，那么应该和我们编译的补全效果一样；如果是在上传模板后，也许应该借此减掉补全内容所占的尺寸

结合小程序代码包传递过程和样式补全时机，大概有以下 3 种情况：

**阶段一补全：**

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd711653c9a44f8c8a61b0bc4d7b2f09~tplv-k3u1fbpfcp-watermark.awebp">

**阶段二：**

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/980244c1c48548808b63ec8a1db0eaa0~tplv-k3u1fbpfcp-watermark.awebp">

**阶段三：**

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/652b96abcf6644299334b6ac1db5df3e~tplv-k3u1fbpfcp-watermark.awebp">

为了验证猜想，来做一个实验，比较【 项目编译不补全样式 + 开发者工具设置样式补全 】VS 【 项目编译补全样式 + 开发者工具不设置样式补全  】，模板体积统计如下：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e22365a55d854e6a9106cfacfc100033~tplv-k3u1fbpfcp-watermark.awebp">



<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/605ce8afc3e54b078272c25a3209900e~tplv-k3u1fbpfcp-watermark.awebp">

可见前者比后者少了 58kb，这说明，开发者工具提供的样式补全不是在阶段一做的，不然模板体积应该和我们自己做的编译补全基本一致。

**那么，就可以愉快的去掉编译补全，使用小程序开发者工具提供的能力了。**

不过这样改动会出现一个小问题，开发者工具内的样式是未经补全处理的，个别样式会有点问题，测试就发现 mask-border-source 无效，而相应真机因为已添加样式补全没有问题。为了不出现预览误会，建议给这种尚未支持的样式手动写上 -webkit- 前缀，保证开发和真机表现一致。

### 小心 Sass

sass/less 等工具使得 CSS 的编写变得更加流畅，函数和变量的引入也让 CSS 有了一点工程化的意味。但你有没有观察过 sass 的编译实现呢？

```js
// a.sass 作为被引用方
.banner { // 样式定义
    color: red;
}
@COLOR = res; // 变量定义（函数定义类型）

b.scss 作为使用方
import 'a.scss';
.banner_wrapper {
    background: white;
    color: $COLOR
}
```

关注 b.sass 的编译后

```js
// a.scss 的引用消失了，内容被整合到文件内

.banner {
    color: red;
}
.banner_wrapper {
    background: white;
    color: red;
}
```

这里出现的问题是：我们是否需要 .banner 被拷贝进来呢

为了避免引入不需要的样式定义，有以下几个方向：

- 按功能拆分  a.scss 内的样式定义，按需引入
- 使用 @include 语法，将 banner 的定义变成一个变量，按需引入

而在小程序场景，wxss 语法支持 @import，实现了极弱版的模块化，使得我们可以再加一个角度解决上面的问题：

- 绕过 sass 编译，使用小程序的 @import 语法，引入需要的样式定义。（关于如何绕开 sass 编译，可以考虑使用注释片段，或者白名单筛选识别）

### 多端场景的冗余代码移除

京喜首页项目使用 Taro 开发，需要适配 H5/微信小程序/QQ小程序等多端场景，利用 Taro 提供的环境变量场景，可以在方法内部实现多端差异处理，比如下面这段：

```js
init() {
    if(process.env.TARO_ENV === "weapp") {
        // 微信小程序逻辑
        thi.initWeapp();
    }else if(process.env.TARO_ENV === "h5") {
        // H5 页面逻辑
        this.initH5();
    }
}

initWeapp() {...}
initH5() {...}
```

小程序端打包后代码：

``` {
init() {
	this.initWeapp();
}
initWeapp() {...}
initH5() {...}
```

但是，环境变量方式没办法处理 initH5 这种方式定义，导致也被打包进来了

因此，我们需要更强大的差异打包：京喜首页利用内部的 wxa-cli 工具提供的条件编译能力，通过注册段落标记，圈注出多端内容，实现了代码片段层面的差异打包，细节如下：

```js
init() {
    if(process.env.TARO_ENV === "weapp") {
        // 微信小程序逻辑
        thi.initWeapp();
    }else if(process.env.TARO_ENV === "h5") {
        // H5 页面逻辑
        this.initH5();
    }
}

initWeapp() {...}
/* wxa if:type==="h5" */ 标记H5端代码开始位置
initH5() {...}
/* /wxa */               标记注释结束位置
```

打包后的代码：

```js
init() { // weapp 内
    this.initWeapp();
}
initWeapp() {...}
```

initH5 消失了，代码更瘦了

### 整理 log

为了方便调试，你的项目内有没有打很长的 log，类似于这种：

```js
console.log("=====================xx接口异常====================");
```

经过测试，首页代码文件内有 5KB 的内容是 log 语句，可以试着优化一下：

- 及时移除开发调试用 log
- 信息类 log 约定长度更短的格式

### 良好的编码策略

有没有同样的逻辑需求，可以用更短更优雅的写法来实现呢？

关于代码分析是个很复杂的话题，暂时列出一个结论相对明确的写法吧

格式化数据时数据的存取和中间变量问题

```js
function format(list) {
    let result = [];
    list.forEach(item => {
        const {
            a,
            b,
            c: f,
            d,
            e
        } = item
        
        result.push({
            a, 
            b,
            f,
            d,
            e
        })
    })
}

return result;
```

可以利用 lodash 的 pick 方法改写成：

```js
import { pick } from "lodash/pick"

fucntion format(list) {
    return list.map(item -> ({
        ...pick(item, 'a', 'b', 'd', 'e'),
        f: item.c
    }))
}
```

### 样式命名编译优化

京喜首页项目由于 H5 端混搭老项目，为了避免类名冲突，采用了形如 block-name_element--modifier 的 bem 命名规则。在开发中进一步发现，一些类似 navbar-content_item 的常见命名偶尔撞车，为了避免冲突，类名就越写越长，而小程序代码包的尺寸影响也在悄悄增大。

为了解决类名冲突的问题，将类名 hash 化是个好办法，css-module 就是一个成熟的插件，可以通过配置规则，对样式名编译出【文件名 + 内容相关】的独特化 hash

但是研究下它的实现，会发现对代码尺寸的影响不容乐观，看一个编译后的例子：

```js
import style from './index.module.map/scss.js' // JS 文件，增加一句 jsMap 的引入

<view className={style.banner}></view> // wxml 文化，每处类名都比原生类名增加了 `style.` 的引用

.hash {xx} // wxss 文件，类型被 hash 化，减少的具体尺寸为：原类名 - hash

module.exports = { banner: hash } // 新增了一个 map 文件，实现原名与 hash 名的映射，增加的具体尺寸为：原类名 + hash
```

计算整体内容变化：

- JS 内新增月入 map 语句：增加一句代码
- wxml 内：原为 n 个类名，现为 n 个 [style. + 原类名]，增量为 n 个 style
- map 文件与 wxss 文件合计：map 内有 n 个原类名与 hash 映射，wxss 现为 n 个 hash，减去原来的 n 个原类名，合计增量为 2n 个 hash

可见引入 css-module 会导致整体代码尺寸增加

会不会觉得这个新增的 map 文件的作用特别熟悉呢？

在我们压缩 JS 文件时，会有一个 sourceMap 文件，它保留了原始命名和代码位置，可以方便定位和 debug

css-modules 实现的 map 文件，在我看来作用和 sourceMap 的命名索引差不多，对于代码逻辑来说，除了保持原类名的引用信息，它好像也没什么用了，在尺寸敏感场景，就要可以考虑去掉 map 文件，如果实现成这样就好了

```js
// importg style from "./index.module.map.scss.js" JS 文件取消 map 的引入

// wxml 文件
<view className="hash"></view>

// wxss 文件
.hash { xx } // 这里不变

module.exports = { banner: hash } // 删掉不要
```

网上遍寻没有相关的处理，只能自己造轮子开搞了

由于当前主要目的是对小程序代码瘦身，H5 端文件处理和小程序也有一些差异，所以暂时只对小程序场景造的插件，取名 weapp-css-modules

大致思路是：

- 完成小程序 css-modules 实现
- 在此基础上进行 map 移除的相关简化逻辑
- 进一步的，考虑到小程序内默认样式隔离的特性，对 hash 化命名再次缩短，变成单字母编排

如果是只开发小程序端，可以借此实现小程序样式命名相关的代码瘦身，而对于 Taro 开发多端场景，还可以同时解决 H5 端的命名冲突问题

还是上面的例子。下面是 weapp-css-module 编译后的效果：

```js
// js 文件
let style = {} // 不引用 map，加入对不规范引入 style 的兼容

// wxml 文件
<view className="a"><view> // 对 style.banner 进行求值并替换，加入单字母编排
    
// wxss 文件
.a { xx } // 因为小程序组件样式隔离，所以可以最短化类名

module.exports = { banner: hash } // 删除不要
```

京喜首页项目通过改造组件采用 css-module 写法，加上 weapp-css-modules 编译，代码相对尺寸减少了 10%，还是很有效果的。

## 总结

关于代码瘦身，想提一下信息学中中熵的概念：熵反应信息的无序程度，一段信息无序程度越低，它的熵值越低，可被压缩的空间越大；无序程度越高，可被压缩的空间越小。而数据压缩或者是代码瘦身的过程，就是通过优化信息存储方式以逼近它真实的熵值。

从这个角度来说：

- 【字体和颜色的全局共用】和【样式补全功能的使用】是借用小程序提供的能力，信息量没变
- 【小心 Sass】丶【多端场景的冗余代码移除】是减少不必要的小心
- 【整理 log】和【样式命名编译优化】是提炼有效信息

看起来最不好归类的是【良好的编码策略】，它是在编译阶段对信息的梳理和整合，也算凝练有效信息

以上就是京喜首页项目这次代码瘦身的主要方式，除此之外的输出不用文件丶整合公共文件这些体力活，我就不再哆嗦了。通过以上方式，京喜首页代码再原本优化良好的基础上，实现了再次减重 30% 的目标，希望给小程序开发者们带来有价值的信息和思考。





# 41. 极致追求，让小程序代码包立减 10% 的插件 weapp-css-module

小程序的简化版，比标准 css-module 代码量更少的优化方案

## 介绍

css-modules 是一种 CSS 模块化方案，它在构建过程中生成一种原类名与新类名的 map，根据 map 引用样式，通过设定 hash 规则，实现了对 CSS 类名作用域的限定，它通常用来解决页面类名冲突的问题。由于微信小程序内组件样式默认隔离，为什么要使用 css-modules 呢？

有以下 2 个原因

- hash 化后可以实现更短的命名，减少代码体积
- 跨段项目需要兼顾小程序环境，避免样式冲突

标准 css-module 方案：

```js
import style from './index.wxss'
<view class="{{style.banner}}"></view>
.index_banner_xkpkl {{xx}}
module.exports = {"banner": "index_banner_xkpkl"} // 额外生成的 map 文件
```

weapp-css-modules 编译后效果：

```js
let style = {};
<view class="a"></a>
.a { xx }
```

## 安装

目前只开发了适用于 gulp 编译小程序的 gulp 插件，后续计划开发 webpack 可用的插件实现相同功能

```js
npm i guklp-weapp-css-modules gulp-sort
```

``` r
// gulpfile.js
const { weappCssModule, wcmSortFn } = require("gulp-weapp-css-modules");
const sort = require("gulp-sort");


gulp.task("css-module", () => {
    return gulp.src("./src/**/*");
    	.pipe(sort(wcmSortFn))     // 由于处理文件有顺序用来，需要先对文件排序
    	.pipe(weappCssModule())
    	.pipe(gulp.dest("./dist"))
})
```

## 使用

小程序页面不具备隔离功能，因此只有具备样式隔离的 Component 可以改造使用 weap-css-modules

- css 文件改名字：weapp-css-modules 通过 css 是否带 module 来识别需要替换的内容

  `index.css` -> `index.module.wxss`

  // 或者使用 scss/其它

  `index.scss` -> `index.module.scss`

- js 内新增样式文件的引入，目的是建立 css-modules 的样式与 js 关系

  ```js
  import style from './index.module.wxss'
  
  data: {
      ...,
      styles: styles    
  }
  ```

- 修改 js 内类名的地方替换为 styles 的间接引入

  ```js
  query.select('.banner')
  	 .boundingClientRect()
  	 exec(function() {...})
       
  // 改为
  query.select('.' + style['banner'])
  .boundingClientRect()
  .exec(function(res) {...})                      
  ```

- 修改 wxml 内类名的使用

  - 普通类名

    ```jks
    <view class="banner"></view>
    // 改为
    <view class=”{{styles.banner}}“></view>
    // 或者
    <view class="{{styles['banner']}}"></view>
    ```

  - 三目运算符

    ```js
    <view class="banner_dot {{ 'banner_dot--' + 9index == swiperCurrent ? 'cur': '')}}"></view>
    
    // 改为
    <view class="{{styles['banner_dot'] + ' ' + (index == swiperCurrent ? styles['banner_dot==cur'] : '')}}"></view>
    
    // 或者
    <view class="{{`${style["banner_dot"]} ${index == swiperCurrent ? style['banner_dot--cur'] : ''}`}}">
    ```

    这里需要注意几种有问题的写法：

    - 类名间未加空格

      ```js
      <view class="{{style['banner_dot'] + (index == swiperCurrent ? styles['banner_dot--cur'] : '')}}"></view>
      ```

    - 三目表达式未加括号，运算优先级不明

      ```js
      <view class="{{styles['bannner_dot'] + ' ' + index == swiperCurrent ? styles['banner_dot--cur'] : ''}}"></view>
      ```

    - styles 的属性需要的是具体的字符串，不能使用变量表达式（这是 weapp-css-module 需要单独注意的地方，因为编译阶段会对 styles.xx 进行求值，所以不能把表达式写在属性位置）

      ```js
      <view class="{{styles['banner_dot'] + ' ' + styles[index == swiperCurrent ? 'banner_dot--cur' : '']}}"><view>
      ```

- 构建过程中注意脚本的红色提示，类似于这种：

  <img src="https://segmentfault.com/img/bVcKIMx">

  这是由于在 js/wxml 内使用了一个 banner_swiper_2，而 css 内并没有定义 banner_swiper_2，css-module 编译的 map 文件是根据 css 内的样式定义生成 key 名的，因此 styles['banner_swiper_2'] 是 undefined，针对这种情况有两种处理方式：

  - 如果 js 内需要通过这个类名选择到某个元素，但是 css 内不需要编写样式，那么可以将它视为不需要编译的类名，即：

    ```js
    query.selector('.banner_swiper_2'); // 不改成 styles.xx 的写法
    <view class="banner_swiper_2"></view> // 相应的元素也不索引到 styles
    // 这样实现了一个组件内不会被编译的样式
    ```

  - 如果 js 内无引用，那么删掉 wxml 内该类名的定义

- 构建完进行检查，关注样式和交互是否正常





# 42. 小程序零开发埋点，就是这么简单!

> Taro 引入了腾讯有数的微信小程序无痕埋点能力，为 Taro 的开发者提供真*零开发的 8 大无痕埋点能力以及自定义埋点能力，包含小程序启动丶显示丶隐藏丶页面浏览丶页面离开丶分享丶下拉刷新丶上拉触底等八大自动化埋点以及搜索丶商品归因等定制化埋点，以及经营分析丶直播埋点丶导购分析等能力，让你的小程序可以基于微信生态，串联全场景多触点，实现全域经营洞察。

随着入口红利的结束，用户增长面临瓶颈期，如何寻找新的增长点成为企业发张面临的问题。微信作为国内社交巨头，拥有大量流量，同时天然的社交属性为商业变现提供了良好的生态环境。小程序作为微信生态中变现的战略重点，潜力巨大。据最新数据显示，小程序日活跃用户超过 4 亿，累积创造 8000 亿交易额，成为每个开发者都需要关注的问题。

开发小程序的团队虽多，但实际效果却各不相同。如何让开发出来但小程序实现快速增长，发挥社交规模效应，成为每个开发者都需要关注的问题

腾讯有数作为腾讯官方推出的微信生态内数据分析和数据应用的平台，可以为开发者提供流量数据检测丶渠道评估，用户洞察丶经营诊断丶精确营销等能力，指导运营决策

目前，Taro 与腾讯有数已达成官方合作，Taro 的开发者可通过零开发丶无痕埋点能力以及自定义埋点能力，串联微信内全场景多触点，实现全域数据洞察。

## 一键安装，实现真*零开发埋点

为了让开发者更简单的接入体验无痕埋点能力，腾讯有数联合 Taro 从多个角度思考，打破边界，从 Taro 命令行丶Taro 模板丶有数小程序 SDK丶数据流转链路多个角度优化，调整了 11 个纵向数据流转链路丶打通数据接入 4 个阶段，13 个环节，将数据接入体验从 3-5 天缩短至 10 分钟。最后呈现出开发者零开发丶零配置的从 0 到 1的数据埋点体验。

腾讯有数 & Taro 合作开发的微信小程序模板，可以快速的通过命令行一键安装，无需任何开发即可拥有小程序启动丶显示丶隐藏丶页面浏览丶页面离开丶分享丶下拉刷新丶上拉触底等八大自动化埋点能力。对于现存小程序，腾讯有数 & Taro 也提供了可以自动化分析丶引入 SDK 的插件，可以实现零开发引入 SDK，让小程序开发者从繁琐的埋点开发中解脱出来，直接引入基础埋点功能

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/7/17326deb324bfbfa~tplv-t2oaga2asx-watermark.awebp">

流程示意图

## Taro * 有数，助力全域数据分析

接入有数后，开发者可以在平台中查看流量指标丶渠道来源丶用户趋势丶人群画像丶公众号直播等数据维度，了解当前小程序运营状况，实现数据驱动增长

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/7/17326debc881b714~tplv-t2oaga2asx-watermark.awebp">

同时，除了基础经营指标外，有数还提供商品分析与推荐丶精确营销丶人群推荐等高阶能力，如有需要可

## 如何使用

### 新建小程序快速体验指南

> 需要升级 Taro 到 2.x 或 3.x

- taro init myApp
- 选择 default-youshu 模板
- npm run dev:weapp
- 微信小程序开发者工具
- 访问 docs.qq.com/form/fill/D…  申请有数数据查看权限

> 通过上述流程已经让你的微信小程序拥有了 8 大用户行为埋点的体验能力，体验完成后，只需要更换有数的 Token 和微信小程序 appid，即拥有有数的正式版功能。正式账号获取路径docs.qq.com/form/fill/D…

### 现存小程序的有数 SDK 接入

**1. 安装**

- 通过 npm 安装 SDK `npm i sr-sdk-wxapp`
- 在 app.jsx 中通过 import 引入 SDK `import sr from 'sr-sdk-wxapp'` 

**2. 添加可信域名**

登录微信公众号，进入<开发><开发设置><服务器域名>，将 http://zhls.qq.com 添加为 request 合法域名

> 在开发者环境还有 SDK 版本检查，所以会提示 https://sr-home-1257214331.cos.ap-guangzhou.myqcloud.com  不在以下 request 合法域名列表中，可以通过设置不校验域名处理

**3. init 初始化**

init (options: object)

配置接口，用来调整 SDK 的基础机制。应该在 App() 调用之前调用

首次调用初始化 SDK，再次调用覆盖之前传入的配置，可多次调用

| 名称              | 类型   | 必填 | 描述                                                         |
| ----------------- | ------ | ---- | ------------------------------------------------------------ |
| appid             | string | Y    | 微信小程序化 appid                                           |
| token             | string | Y    | 通过接入申请后，有数提供的凭证字符串                         |
| usePlugin         | bool   |      | 是否使用了小程序插件，默认是 false                           |
| debug             | bool   |      | 是否打印日志，默认是 false                                   |
| openSdkShareDepth | bool   |      | 是否打开分享链路记录功能，默认值为 false，打开后，将记录用户分享链路 A-B-C-D |
| serverUrl         | string |      | 传入自定义的后台上报接口，若传入则 token 将无意义，默认是：`zhls.qq.com/api/report` |
| trackApp          | bool   |      | 是否开启自动跟踪 APP 的曝光时间（APP 相关预警事件，如 APP-onLuanch），默认是：true |
| proxyPage         | bool   |      | 是否开启自动代理 Page，默认是：false。SDK 负责上报页面的 browse丶leave丶share等事件可以使用 sr.page 代替 Page(sr.page(options)) |
| autoStart         | bool   |      | 是否开启自动开始上报，默认是：false，open_id 无法自动获取，一般是在 login 业务之后手动调用 sr.startReport 方法开启上报 |

**4. 示例**

```js
import sr from 'sr-sdk-wxapp'
sr.init({
    /** 
    * 有数 -ka "接入测试用" 分配的 app_id，对应的业务接口人负责
    */
	token: "bi72fccc7184ef4xxx",
    /**
    * 微信小程序 appID，以 wx 开头
    */
    appid: "wx195745e8e342bxxx",
    /**
    * 如果使用了小程序插件，需要设置为 true
    */
    usePlugin: false,
    /**
    * 开启打印调试信息，默认 false
    */
    debug: true,
    /**
    * 建议开启-开启自动代理 Page，默认 false
    * sdk 负责上报页面的 browse丶leave丶share 等事件
    * 可以使用 sr.page 代替 Page(sr.page(options))
    * 元素事件跟踪，需要配合 autoTrack: true
    */
    proxyPage: true,
    /**
    * 建议开启-开启组件自动代理，默认 false
    * sdk 负责上报页面的 browse丶leave丶share 等事件
    */
    proxyComponent: true,
    // 建议开启-是否开启页面分享链路自动跟踪
    openSdkShareDepth: true
    // 建议开启-元素事件跟踪，自动上报元素事件，入 tap丶change丶longpress丶confirm
    autoTrack: true
})
```

了解更多腾讯有数的无痕埋点 SDK，支持微信小程序丶Taro丶mpvue丶WePY丶uni-app







# 43. 小程序 storage 可以存储多大的内存?

将数据存储在本地缓存中指定的 key 中。回覆盖掉原来该 key 对应的内容。除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。



























# 反思做过小程序的业务价值丶亮点丶贡献